// Code generated by ogen, DO NOT EDIT.

package examples

import (
	"fmt"
	"math/bits"
	"regexp"
	"strconv"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"
)

var regexMap = map[string]*regexp.Regexp{
	"^":                     regexp.MustCompile("^"),
	"^([0-9X]{3})$":         regexp.MustCompile("^([0-9X]{3})$"),
	"^/":                    regexp.MustCompile("^/"),
	"^[a-zA-Z0-9\\.\\-_]+$": regexp.MustCompile("^[a-zA-Z0-9\\.\\-_]+$"),
	"^x-":                   regexp.MustCompile("^x-"),
}

// Ref: #/definitions/anysOrExpressions
type DefinitionsAnysOrExpressions map[string]jx.Raw

func (s *DefinitionsAnysOrExpressions) init() DefinitionsAnysOrExpressions {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// A map of possible out-of band callbacks related to the parent operation. Each value in the map is
// a Path Item Object that describes a set of requests that may be initiated by the API provider and
// the expected responses. The key value used to identify the callback object is an expression,
// evaluated at runtime, that identifies a URL to use for the callback operation.
// Ref: #/definitions/callback
type DefinitionsCallback struct {
	AdditionalProps DefinitionsCallbackAdditional
	Pattern0Props   DefinitionsCallbackPattern0
	Pattern1Props   DefinitionsCallbackPattern1
}

type DefinitionsCallbackAdditional map[string]jx.Raw

func (s *DefinitionsCallbackAdditional) init() DefinitionsCallbackAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/callbackOrReference
// DefinitionsCallbackOrReference represents sum type.
type DefinitionsCallbackOrReference struct {
	Type                 DefinitionsCallbackOrReferenceType // switch on this field
	DefinitionsCallback  DefinitionsCallback
	DefinitionsReference DefinitionsReference
}

// DefinitionsCallbackOrReferenceType is oneOf type of DefinitionsCallbackOrReference.
type DefinitionsCallbackOrReferenceType string

// Possible values for DefinitionsCallbackOrReferenceType.
const (
	DefinitionsCallbackDefinitionsCallbackOrReference  DefinitionsCallbackOrReferenceType = "DefinitionsCallback"
	DefinitionsReferenceDefinitionsCallbackOrReference DefinitionsCallbackOrReferenceType = "DefinitionsReference"
)

// IsDefinitionsCallback reports whether DefinitionsCallbackOrReference is DefinitionsCallback.
func (s DefinitionsCallbackOrReference) IsDefinitionsCallback() bool {
	return s.Type == DefinitionsCallbackDefinitionsCallbackOrReference
}

// IsDefinitionsReference reports whether DefinitionsCallbackOrReference is DefinitionsReference.
func (s DefinitionsCallbackOrReference) IsDefinitionsReference() bool {
	return s.Type == DefinitionsReferenceDefinitionsCallbackOrReference
}

// SetDefinitionsCallback sets DefinitionsCallbackOrReference to DefinitionsCallback.
func (s *DefinitionsCallbackOrReference) SetDefinitionsCallback(v DefinitionsCallback) {
	s.Type = DefinitionsCallbackDefinitionsCallbackOrReference
	s.DefinitionsCallback = v
}

// GetDefinitionsCallback returns DefinitionsCallback and true boolean if DefinitionsCallbackOrReference is DefinitionsCallback.
func (s DefinitionsCallbackOrReference) GetDefinitionsCallback() (v DefinitionsCallback, ok bool) {
	if !s.IsDefinitionsCallback() {
		return v, false
	}
	return s.DefinitionsCallback, true
}

// NewDefinitionsCallbackDefinitionsCallbackOrReference returns new DefinitionsCallbackOrReference from DefinitionsCallback.
func NewDefinitionsCallbackDefinitionsCallbackOrReference(v DefinitionsCallback) DefinitionsCallbackOrReference {
	var s DefinitionsCallbackOrReference
	s.SetDefinitionsCallback(v)
	return s
}

// SetDefinitionsReference sets DefinitionsCallbackOrReference to DefinitionsReference.
func (s *DefinitionsCallbackOrReference) SetDefinitionsReference(v DefinitionsReference) {
	s.Type = DefinitionsReferenceDefinitionsCallbackOrReference
	s.DefinitionsReference = v
}

// GetDefinitionsReference returns DefinitionsReference and true boolean if DefinitionsCallbackOrReference is DefinitionsReference.
func (s DefinitionsCallbackOrReference) GetDefinitionsReference() (v DefinitionsReference, ok bool) {
	if !s.IsDefinitionsReference() {
		return v, false
	}
	return s.DefinitionsReference, true
}

// NewDefinitionsReferenceDefinitionsCallbackOrReference returns new DefinitionsCallbackOrReference from DefinitionsReference.
func NewDefinitionsReferenceDefinitionsCallbackOrReference(v DefinitionsReference) DefinitionsCallbackOrReference {
	var s DefinitionsCallbackOrReference
	s.SetDefinitionsReference(v)
	return s
}

type DefinitionsCallbackPattern0 map[string]DefinitionsPathItem

func (s *DefinitionsCallbackPattern0) init() DefinitionsCallbackPattern0 {
	m := *s
	if m == nil {
		m = map[string]DefinitionsPathItem{}
		*s = m
	}
	return m
}

type DefinitionsCallbackPattern1 map[string]jx.Raw

func (s *DefinitionsCallbackPattern1) init() DefinitionsCallbackPattern1 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/callbacksOrReferences
type DefinitionsCallbacksOrReferences map[string]DefinitionsCallbackOrReference

func (s *DefinitionsCallbacksOrReferences) init() DefinitionsCallbacksOrReferences {
	m := *s
	if m == nil {
		m = map[string]DefinitionsCallbackOrReference{}
		*s = m
	}
	return m
}

// Holds a set of reusable objects for different aspects of the OAS. All objects defined within the
// components object will have no effect on the API unless they are explicitly referenced from
// properties outside the components object.
// Ref: #/definitions/components
type DefinitionsComponents struct {
	Schemas         OptDefinitionsSchemasOrReferences         "json:\"schemas\""
	Responses       OptDefinitionsResponsesOrReferences       "json:\"responses\""
	Parameters      OptDefinitionsParametersOrReferences      "json:\"parameters\""
	Examples        OptDefinitionsExamplesOrReferences        "json:\"examples\""
	RequestBodies   OptDefinitionsRequestBodiesOrReferences   "json:\"requestBodies\""
	Headers         OptDefinitionsHeadersOrReferences         "json:\"headers\""
	SecuritySchemes OptDefinitionsSecuritySchemesOrReferences "json:\"securitySchemes\""
	Links           OptDefinitionsLinksOrReferences           "json:\"links\""
	Callbacks       OptDefinitionsCallbacksOrReferences       "json:\"callbacks\""
	AdditionalProps DefinitionsComponentsAdditional
	Pattern0Props   DefinitionsComponentsPattern0
}

type DefinitionsComponentsAdditional map[string]jx.Raw

func (s *DefinitionsComponentsAdditional) init() DefinitionsComponentsAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsComponentsPattern0 map[string]jx.Raw

func (s *DefinitionsComponentsPattern0) init() DefinitionsComponentsPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Contact information for the exposed API.
// Ref: #/definitions/contact
type DefinitionsContact struct {
	Name            OptString "json:\"name\""
	URL             OptString "json:\"url\""
	Email           OptString "json:\"email\""
	AdditionalProps DefinitionsContactAdditional
	Pattern0Props   DefinitionsContactPattern0
}

type DefinitionsContactAdditional map[string]jx.Raw

func (s *DefinitionsContactAdditional) init() DefinitionsContactAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsContactPattern0 map[string]jx.Raw

func (s *DefinitionsContactPattern0) init() DefinitionsContactPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// When request bodies or response payloads may be one of a number of different schemas, a
// `discriminator` object can be used to aid in serialization, deserialization, and validation.  The
// discriminator is a specific object in a schema which is used to inform the consumer of the
// specification of an alternative schema based on the value associated with it.  When using the
// discriminator, _inline_ schemas will not be considered.
// Ref: #/definitions/discriminator
type DefinitionsDiscriminator struct {
	PropertyName    string                "json:\"propertyName\""
	Mapping         OptDefinitionsStrings "json:\"mapping\""
	AdditionalProps DefinitionsDiscriminatorAdditional
}

type DefinitionsDiscriminatorAdditional map[string]jx.Raw

func (s *DefinitionsDiscriminatorAdditional) init() DefinitionsDiscriminatorAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// A single encoding definition applied to a single schema property.
// Ref: #/definitions/encoding
type DefinitionsEncoding struct {
	ContentType     OptString                         "json:\"contentType\""
	Headers         OptDefinitionsHeadersOrReferences "json:\"headers\""
	Style           OptString                         "json:\"style\""
	Explode         OptBool                           "json:\"explode\""
	AllowReserved   OptBool                           "json:\"allowReserved\""
	AdditionalProps DefinitionsEncodingAdditional
	Pattern0Props   DefinitionsEncodingPattern0
}

type DefinitionsEncodingAdditional map[string]jx.Raw

func (s *DefinitionsEncodingAdditional) init() DefinitionsEncodingAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsEncodingPattern0 map[string]jx.Raw

func (s *DefinitionsEncodingPattern0) init() DefinitionsEncodingPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/encodings
type DefinitionsEncodings map[string]DefinitionsEncoding

func (s *DefinitionsEncodings) init() DefinitionsEncodings {
	m := *s
	if m == nil {
		m = map[string]DefinitionsEncoding{}
		*s = m
	}
	return m
}

// Ref: #/definitions/example
type DefinitionsExample struct {
	Summary         OptString "json:\"summary\""
	Description     OptString "json:\"description\""
	Value           jx.Raw    "json:\"value\""
	ExternalValue   OptString "json:\"externalValue\""
	AdditionalProps DefinitionsExampleAdditional
	Pattern0Props   DefinitionsExamplePattern0
}

type DefinitionsExampleAdditional map[string]jx.Raw

func (s *DefinitionsExampleAdditional) init() DefinitionsExampleAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/exampleOrReference
// DefinitionsExampleOrReference represents sum type.
type DefinitionsExampleOrReference struct {
	Type                 DefinitionsExampleOrReferenceType // switch on this field
	DefinitionsExample   DefinitionsExample
	DefinitionsReference DefinitionsReference
}

// DefinitionsExampleOrReferenceType is oneOf type of DefinitionsExampleOrReference.
type DefinitionsExampleOrReferenceType string

// Possible values for DefinitionsExampleOrReferenceType.
const (
	DefinitionsExampleDefinitionsExampleOrReference   DefinitionsExampleOrReferenceType = "DefinitionsExample"
	DefinitionsReferenceDefinitionsExampleOrReference DefinitionsExampleOrReferenceType = "DefinitionsReference"
)

// IsDefinitionsExample reports whether DefinitionsExampleOrReference is DefinitionsExample.
func (s DefinitionsExampleOrReference) IsDefinitionsExample() bool {
	return s.Type == DefinitionsExampleDefinitionsExampleOrReference
}

// IsDefinitionsReference reports whether DefinitionsExampleOrReference is DefinitionsReference.
func (s DefinitionsExampleOrReference) IsDefinitionsReference() bool {
	return s.Type == DefinitionsReferenceDefinitionsExampleOrReference
}

// SetDefinitionsExample sets DefinitionsExampleOrReference to DefinitionsExample.
func (s *DefinitionsExampleOrReference) SetDefinitionsExample(v DefinitionsExample) {
	s.Type = DefinitionsExampleDefinitionsExampleOrReference
	s.DefinitionsExample = v
}

// GetDefinitionsExample returns DefinitionsExample and true boolean if DefinitionsExampleOrReference is DefinitionsExample.
func (s DefinitionsExampleOrReference) GetDefinitionsExample() (v DefinitionsExample, ok bool) {
	if !s.IsDefinitionsExample() {
		return v, false
	}
	return s.DefinitionsExample, true
}

// NewDefinitionsExampleDefinitionsExampleOrReference returns new DefinitionsExampleOrReference from DefinitionsExample.
func NewDefinitionsExampleDefinitionsExampleOrReference(v DefinitionsExample) DefinitionsExampleOrReference {
	var s DefinitionsExampleOrReference
	s.SetDefinitionsExample(v)
	return s
}

// SetDefinitionsReference sets DefinitionsExampleOrReference to DefinitionsReference.
func (s *DefinitionsExampleOrReference) SetDefinitionsReference(v DefinitionsReference) {
	s.Type = DefinitionsReferenceDefinitionsExampleOrReference
	s.DefinitionsReference = v
}

// GetDefinitionsReference returns DefinitionsReference and true boolean if DefinitionsExampleOrReference is DefinitionsReference.
func (s DefinitionsExampleOrReference) GetDefinitionsReference() (v DefinitionsReference, ok bool) {
	if !s.IsDefinitionsReference() {
		return v, false
	}
	return s.DefinitionsReference, true
}

// NewDefinitionsReferenceDefinitionsExampleOrReference returns new DefinitionsExampleOrReference from DefinitionsReference.
func NewDefinitionsReferenceDefinitionsExampleOrReference(v DefinitionsReference) DefinitionsExampleOrReference {
	var s DefinitionsExampleOrReference
	s.SetDefinitionsReference(v)
	return s
}

type DefinitionsExamplePattern0 map[string]jx.Raw

func (s *DefinitionsExamplePattern0) init() DefinitionsExamplePattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/examplesOrReferences
type DefinitionsExamplesOrReferences map[string]DefinitionsExampleOrReference

func (s *DefinitionsExamplesOrReferences) init() DefinitionsExamplesOrReferences {
	m := *s
	if m == nil {
		m = map[string]DefinitionsExampleOrReference{}
		*s = m
	}
	return m
}

// Allows referencing an external resource for extended documentation.
// Ref: #/definitions/externalDocs
type DefinitionsExternalDocs struct {
	Description     OptString "json:\"description\""
	URL             string    "json:\"url\""
	AdditionalProps DefinitionsExternalDocsAdditional
	Pattern0Props   DefinitionsExternalDocsPattern0
}

type DefinitionsExternalDocsAdditional map[string]jx.Raw

func (s *DefinitionsExternalDocsAdditional) init() DefinitionsExternalDocsAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsExternalDocsPattern0 map[string]jx.Raw

func (s *DefinitionsExternalDocsPattern0) init() DefinitionsExternalDocsPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// The Header Object follows the structure of the Parameter Object with the following changes:  1.
// `name` MUST NOT be specified, it is given in the corresponding `headers` map. 1. `in` MUST NOT be
// specified, it is implicitly in `header`. 1. All traits that are affected by the location MUST be
// applicable to a location of `header` (for example, `style`).
// Ref: #/definitions/header
type DefinitionsHeader struct {
	Description     OptString                          "json:\"description\""
	Required        OptBool                            "json:\"required\""
	Deprecated      OptBool                            "json:\"deprecated\""
	AllowEmptyValue OptBool                            "json:\"allowEmptyValue\""
	Style           OptString                          "json:\"style\""
	Explode         OptBool                            "json:\"explode\""
	AllowReserved   OptBool                            "json:\"allowReserved\""
	Schema          OptDefinitionsSchemaOrReference    "json:\"schema\""
	Example         jx.Raw                             "json:\"example\""
	Examples        OptDefinitionsExamplesOrReferences "json:\"examples\""
	Content         OptDefinitionsMediaTypes           "json:\"content\""
	AdditionalProps DefinitionsHeaderAdditional
	Pattern0Props   DefinitionsHeaderPattern0
}

type DefinitionsHeaderAdditional map[string]jx.Raw

func (s *DefinitionsHeaderAdditional) init() DefinitionsHeaderAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/headerOrReference
// DefinitionsHeaderOrReference represents sum type.
type DefinitionsHeaderOrReference struct {
	Type                 DefinitionsHeaderOrReferenceType // switch on this field
	DefinitionsHeader    DefinitionsHeader
	DefinitionsReference DefinitionsReference
}

// DefinitionsHeaderOrReferenceType is oneOf type of DefinitionsHeaderOrReference.
type DefinitionsHeaderOrReferenceType string

// Possible values for DefinitionsHeaderOrReferenceType.
const (
	DefinitionsHeaderDefinitionsHeaderOrReference    DefinitionsHeaderOrReferenceType = "DefinitionsHeader"
	DefinitionsReferenceDefinitionsHeaderOrReference DefinitionsHeaderOrReferenceType = "DefinitionsReference"
)

// IsDefinitionsHeader reports whether DefinitionsHeaderOrReference is DefinitionsHeader.
func (s DefinitionsHeaderOrReference) IsDefinitionsHeader() bool {
	return s.Type == DefinitionsHeaderDefinitionsHeaderOrReference
}

// IsDefinitionsReference reports whether DefinitionsHeaderOrReference is DefinitionsReference.
func (s DefinitionsHeaderOrReference) IsDefinitionsReference() bool {
	return s.Type == DefinitionsReferenceDefinitionsHeaderOrReference
}

// SetDefinitionsHeader sets DefinitionsHeaderOrReference to DefinitionsHeader.
func (s *DefinitionsHeaderOrReference) SetDefinitionsHeader(v DefinitionsHeader) {
	s.Type = DefinitionsHeaderDefinitionsHeaderOrReference
	s.DefinitionsHeader = v
}

// GetDefinitionsHeader returns DefinitionsHeader and true boolean if DefinitionsHeaderOrReference is DefinitionsHeader.
func (s DefinitionsHeaderOrReference) GetDefinitionsHeader() (v DefinitionsHeader, ok bool) {
	if !s.IsDefinitionsHeader() {
		return v, false
	}
	return s.DefinitionsHeader, true
}

// NewDefinitionsHeaderDefinitionsHeaderOrReference returns new DefinitionsHeaderOrReference from DefinitionsHeader.
func NewDefinitionsHeaderDefinitionsHeaderOrReference(v DefinitionsHeader) DefinitionsHeaderOrReference {
	var s DefinitionsHeaderOrReference
	s.SetDefinitionsHeader(v)
	return s
}

// SetDefinitionsReference sets DefinitionsHeaderOrReference to DefinitionsReference.
func (s *DefinitionsHeaderOrReference) SetDefinitionsReference(v DefinitionsReference) {
	s.Type = DefinitionsReferenceDefinitionsHeaderOrReference
	s.DefinitionsReference = v
}

// GetDefinitionsReference returns DefinitionsReference and true boolean if DefinitionsHeaderOrReference is DefinitionsReference.
func (s DefinitionsHeaderOrReference) GetDefinitionsReference() (v DefinitionsReference, ok bool) {
	if !s.IsDefinitionsReference() {
		return v, false
	}
	return s.DefinitionsReference, true
}

// NewDefinitionsReferenceDefinitionsHeaderOrReference returns new DefinitionsHeaderOrReference from DefinitionsReference.
func NewDefinitionsReferenceDefinitionsHeaderOrReference(v DefinitionsReference) DefinitionsHeaderOrReference {
	var s DefinitionsHeaderOrReference
	s.SetDefinitionsReference(v)
	return s
}

type DefinitionsHeaderPattern0 map[string]jx.Raw

func (s *DefinitionsHeaderPattern0) init() DefinitionsHeaderPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/headersOrReferences
type DefinitionsHeadersOrReferences map[string]DefinitionsHeaderOrReference

func (s *DefinitionsHeadersOrReferences) init() DefinitionsHeadersOrReferences {
	m := *s
	if m == nil {
		m = map[string]DefinitionsHeaderOrReference{}
		*s = m
	}
	return m
}

// The object provides metadata about the API. The metadata MAY be used by the clients if needed, and
// MAY be presented in editing or documentation generation tools for convenience.
// Ref: #/definitions/info
type DefinitionsInfo struct {
	Title           string                "json:\"title\""
	Description     OptString             "json:\"description\""
	TermsOfService  OptString             "json:\"termsOfService\""
	Contact         OptDefinitionsContact "json:\"contact\""
	License         OptDefinitionsLicense "json:\"license\""
	Version         string                "json:\"version\""
	AdditionalProps DefinitionsInfoAdditional
	Pattern0Props   DefinitionsInfoPattern0
}

type DefinitionsInfoAdditional map[string]jx.Raw

func (s *DefinitionsInfoAdditional) init() DefinitionsInfoAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsInfoPattern0 map[string]jx.Raw

func (s *DefinitionsInfoPattern0) init() DefinitionsInfoPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsJsonschemaDraft4PropertiesEnum []jx.Raw

type DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum bool

type DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum bool

type DefinitionsJsonschemaDraft4PropertiesMaximum float64

type DefinitionsJsonschemaDraft4PropertiesMinimum float64

type DefinitionsJsonschemaDraft4PropertiesMultipleOf float64

type DefinitionsJsonschemaDraft4PropertiesPattern string

type DefinitionsJsonschemaDraft4PropertiesTitle string

type DefinitionsJsonschemaDraft4PropertiesUniqueItems bool

// License information for the exposed API.
// Ref: #/definitions/license
type DefinitionsLicense struct {
	Name            string    "json:\"name\""
	URL             OptString "json:\"url\""
	AdditionalProps DefinitionsLicenseAdditional
	Pattern0Props   DefinitionsLicensePattern0
}

type DefinitionsLicenseAdditional map[string]jx.Raw

func (s *DefinitionsLicenseAdditional) init() DefinitionsLicenseAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsLicensePattern0 map[string]jx.Raw

func (s *DefinitionsLicensePattern0) init() DefinitionsLicensePattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// The `Link object` represents a possible design-time link for a response. The presence of a link
// does not guarantee the caller's ability to successfully invoke it, rather it provides a known
// relationship and traversal mechanism between responses and other operations.  Unlike _dynamic_
// links (i.e. links provided **in** the response payload), the OAS linking mechanism does not
// require link information in the runtime response.  For computing links, and providing instructions
// to execute them, a runtime expression is used for accessing values in an operation and using them
// as parameters while invoking the linked operation.
// Ref: #/definitions/link
type DefinitionsLink struct {
	OperationRef    OptString                       "json:\"operationRef\""
	OperationId     OptString                       "json:\"operationId\""
	Parameters      OptDefinitionsAnysOrExpressions "json:\"parameters\""
	RequestBody     jx.Raw                          "json:\"requestBody\""
	Description     OptString                       "json:\"description\""
	Server          OptDefinitionsServer            "json:\"server\""
	AdditionalProps DefinitionsLinkAdditional
	Pattern0Props   DefinitionsLinkPattern0
}

type DefinitionsLinkAdditional map[string]jx.Raw

func (s *DefinitionsLinkAdditional) init() DefinitionsLinkAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/linkOrReference
// DefinitionsLinkOrReference represents sum type.
type DefinitionsLinkOrReference struct {
	Type                 DefinitionsLinkOrReferenceType // switch on this field
	DefinitionsLink      DefinitionsLink
	DefinitionsReference DefinitionsReference
}

// DefinitionsLinkOrReferenceType is oneOf type of DefinitionsLinkOrReference.
type DefinitionsLinkOrReferenceType string

// Possible values for DefinitionsLinkOrReferenceType.
const (
	DefinitionsLinkDefinitionsLinkOrReference      DefinitionsLinkOrReferenceType = "DefinitionsLink"
	DefinitionsReferenceDefinitionsLinkOrReference DefinitionsLinkOrReferenceType = "DefinitionsReference"
)

// IsDefinitionsLink reports whether DefinitionsLinkOrReference is DefinitionsLink.
func (s DefinitionsLinkOrReference) IsDefinitionsLink() bool {
	return s.Type == DefinitionsLinkDefinitionsLinkOrReference
}

// IsDefinitionsReference reports whether DefinitionsLinkOrReference is DefinitionsReference.
func (s DefinitionsLinkOrReference) IsDefinitionsReference() bool {
	return s.Type == DefinitionsReferenceDefinitionsLinkOrReference
}

// SetDefinitionsLink sets DefinitionsLinkOrReference to DefinitionsLink.
func (s *DefinitionsLinkOrReference) SetDefinitionsLink(v DefinitionsLink) {
	s.Type = DefinitionsLinkDefinitionsLinkOrReference
	s.DefinitionsLink = v
}

// GetDefinitionsLink returns DefinitionsLink and true boolean if DefinitionsLinkOrReference is DefinitionsLink.
func (s DefinitionsLinkOrReference) GetDefinitionsLink() (v DefinitionsLink, ok bool) {
	if !s.IsDefinitionsLink() {
		return v, false
	}
	return s.DefinitionsLink, true
}

// NewDefinitionsLinkDefinitionsLinkOrReference returns new DefinitionsLinkOrReference from DefinitionsLink.
func NewDefinitionsLinkDefinitionsLinkOrReference(v DefinitionsLink) DefinitionsLinkOrReference {
	var s DefinitionsLinkOrReference
	s.SetDefinitionsLink(v)
	return s
}

// SetDefinitionsReference sets DefinitionsLinkOrReference to DefinitionsReference.
func (s *DefinitionsLinkOrReference) SetDefinitionsReference(v DefinitionsReference) {
	s.Type = DefinitionsReferenceDefinitionsLinkOrReference
	s.DefinitionsReference = v
}

// GetDefinitionsReference returns DefinitionsReference and true boolean if DefinitionsLinkOrReference is DefinitionsReference.
func (s DefinitionsLinkOrReference) GetDefinitionsReference() (v DefinitionsReference, ok bool) {
	if !s.IsDefinitionsReference() {
		return v, false
	}
	return s.DefinitionsReference, true
}

// NewDefinitionsReferenceDefinitionsLinkOrReference returns new DefinitionsLinkOrReference from DefinitionsReference.
func NewDefinitionsReferenceDefinitionsLinkOrReference(v DefinitionsReference) DefinitionsLinkOrReference {
	var s DefinitionsLinkOrReference
	s.SetDefinitionsReference(v)
	return s
}

type DefinitionsLinkPattern0 map[string]jx.Raw

func (s *DefinitionsLinkPattern0) init() DefinitionsLinkPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/linksOrReferences
type DefinitionsLinksOrReferences map[string]DefinitionsLinkOrReference

func (s *DefinitionsLinksOrReferences) init() DefinitionsLinksOrReferences {
	m := *s
	if m == nil {
		m = map[string]DefinitionsLinkOrReference{}
		*s = m
	}
	return m
}

// Each Media Type Object provides schema and examples for the media type identified by its key.
// Ref: #/definitions/mediaType
type DefinitionsMediaType struct {
	Schema          OptDefinitionsSchemaOrReference    "json:\"schema\""
	Example         jx.Raw                             "json:\"example\""
	Examples        OptDefinitionsExamplesOrReferences "json:\"examples\""
	Encoding        OptDefinitionsEncodings            "json:\"encoding\""
	AdditionalProps DefinitionsMediaTypeAdditional
	Pattern0Props   DefinitionsMediaTypePattern0
}

type DefinitionsMediaTypeAdditional map[string]jx.Raw

func (s *DefinitionsMediaTypeAdditional) init() DefinitionsMediaTypeAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsMediaTypePattern0 map[string]jx.Raw

func (s *DefinitionsMediaTypePattern0) init() DefinitionsMediaTypePattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/mediaTypes
type DefinitionsMediaTypes map[string]DefinitionsMediaType

func (s *DefinitionsMediaTypes) init() DefinitionsMediaTypes {
	m := *s
	if m == nil {
		m = map[string]DefinitionsMediaType{}
		*s = m
	}
	return m
}

// Configuration details for a supported OAuth Flow.
// Ref: #/definitions/oauthFlow
type DefinitionsOauthFlow struct {
	AuthorizationUrl OptString             "json:\"authorizationUrl\""
	TokenUrl         OptString             "json:\"tokenUrl\""
	RefreshUrl       OptString             "json:\"refreshUrl\""
	Scopes           OptDefinitionsStrings "json:\"scopes\""
	AdditionalProps  DefinitionsOauthFlowAdditional
	Pattern0Props    DefinitionsOauthFlowPattern0
}

type DefinitionsOauthFlowAdditional map[string]jx.Raw

func (s *DefinitionsOauthFlowAdditional) init() DefinitionsOauthFlowAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsOauthFlowPattern0 map[string]jx.Raw

func (s *DefinitionsOauthFlowPattern0) init() DefinitionsOauthFlowPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Allows configuration of the supported OAuth Flows.
// Ref: #/definitions/oauthFlows
type DefinitionsOauthFlows struct {
	Implicit          OptDefinitionsOauthFlow "json:\"implicit\""
	Password          OptDefinitionsOauthFlow "json:\"password\""
	ClientCredentials OptDefinitionsOauthFlow "json:\"clientCredentials\""
	AuthorizationCode OptDefinitionsOauthFlow "json:\"authorizationCode\""
	AdditionalProps   DefinitionsOauthFlowsAdditional
	Pattern0Props     DefinitionsOauthFlowsPattern0
}

type DefinitionsOauthFlowsAdditional map[string]jx.Raw

func (s *DefinitionsOauthFlowsAdditional) init() DefinitionsOauthFlowsAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsOauthFlowsPattern0 map[string]jx.Raw

func (s *DefinitionsOauthFlowsPattern0) init() DefinitionsOauthFlowsPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Describes a single API operation on a path.
// Ref: #/definitions/operation
type DefinitionsOperation struct {
	Tags            []string                             "json:\"tags\""
	Summary         OptString                            "json:\"summary\""
	Description     OptString                            "json:\"description\""
	ExternalDocs    OptDefinitionsExternalDocs           "json:\"externalDocs\""
	OperationId     OptString                            "json:\"operationId\""
	Parameters      []DefinitionsParameterOrReference    "json:\"parameters\""
	RequestBody     OptDefinitionsRequestBodyOrReference "json:\"requestBody\""
	Responses       DefinitionsResponses                 "json:\"responses\""
	Callbacks       OptDefinitionsCallbacksOrReferences  "json:\"callbacks\""
	Deprecated      OptBool                              "json:\"deprecated\""
	Security        []DefinitionsSecurityRequirement     "json:\"security\""
	Servers         []DefinitionsServer                  "json:\"servers\""
	AdditionalProps DefinitionsOperationAdditional
	Pattern0Props   DefinitionsOperationPattern0
}

type DefinitionsOperationAdditional map[string]jx.Raw

func (s *DefinitionsOperationAdditional) init() DefinitionsOperationAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsOperationPattern0 map[string]jx.Raw

func (s *DefinitionsOperationPattern0) init() DefinitionsOperationPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Describes a single operation parameter.  A unique parameter is defined by a combination of a name
// and location.
// Ref: #/definitions/parameter
type DefinitionsParameter struct {
	Name            string                             "json:\"name\""
	In              DefinitionsParameterIn             "json:\"in\""
	Description     OptString                          "json:\"description\""
	Required        OptBool                            "json:\"required\""
	Deprecated      OptBool                            "json:\"deprecated\""
	AllowEmptyValue OptBool                            "json:\"allowEmptyValue\""
	Style           OptDefinitionsParameterStyle       "json:\"style\""
	Explode         OptBool                            "json:\"explode\""
	AllowReserved   OptBool                            "json:\"allowReserved\""
	Schema          OptDefinitionsSchemaOrReference    "json:\"schema\""
	Example         jx.Raw                             "json:\"example\""
	Examples        OptDefinitionsExamplesOrReferences "json:\"examples\""
	Content         OptDefinitionsMediaTypes           "json:\"content\""
	AdditionalProps DefinitionsParameterAdditional
	Pattern0Props   DefinitionsParameterPattern0
}

type DefinitionsParameterAdditional map[string]jx.Raw

func (s *DefinitionsParameterAdditional) init() DefinitionsParameterAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsParameterIn string

const (
	DefinitionsParameterInPath   DefinitionsParameterIn = "path"
	DefinitionsParameterInQuery  DefinitionsParameterIn = "query"
	DefinitionsParameterInCookie DefinitionsParameterIn = "cookie"
	DefinitionsParameterInHeader DefinitionsParameterIn = "header"
)

// Ref: #/definitions/parameterOrReference
// DefinitionsParameterOrReference represents sum type.
type DefinitionsParameterOrReference struct {
	Type                 DefinitionsParameterOrReferenceType // switch on this field
	DefinitionsParameter DefinitionsParameter
	DefinitionsReference DefinitionsReference
}

// DefinitionsParameterOrReferenceType is oneOf type of DefinitionsParameterOrReference.
type DefinitionsParameterOrReferenceType string

// Possible values for DefinitionsParameterOrReferenceType.
const (
	DefinitionsParameterDefinitionsParameterOrReference DefinitionsParameterOrReferenceType = "DefinitionsParameter"
	DefinitionsReferenceDefinitionsParameterOrReference DefinitionsParameterOrReferenceType = "DefinitionsReference"
)

// IsDefinitionsParameter reports whether DefinitionsParameterOrReference is DefinitionsParameter.
func (s DefinitionsParameterOrReference) IsDefinitionsParameter() bool {
	return s.Type == DefinitionsParameterDefinitionsParameterOrReference
}

// IsDefinitionsReference reports whether DefinitionsParameterOrReference is DefinitionsReference.
func (s DefinitionsParameterOrReference) IsDefinitionsReference() bool {
	return s.Type == DefinitionsReferenceDefinitionsParameterOrReference
}

// SetDefinitionsParameter sets DefinitionsParameterOrReference to DefinitionsParameter.
func (s *DefinitionsParameterOrReference) SetDefinitionsParameter(v DefinitionsParameter) {
	s.Type = DefinitionsParameterDefinitionsParameterOrReference
	s.DefinitionsParameter = v
}

// GetDefinitionsParameter returns DefinitionsParameter and true boolean if DefinitionsParameterOrReference is DefinitionsParameter.
func (s DefinitionsParameterOrReference) GetDefinitionsParameter() (v DefinitionsParameter, ok bool) {
	if !s.IsDefinitionsParameter() {
		return v, false
	}
	return s.DefinitionsParameter, true
}

// NewDefinitionsParameterDefinitionsParameterOrReference returns new DefinitionsParameterOrReference from DefinitionsParameter.
func NewDefinitionsParameterDefinitionsParameterOrReference(v DefinitionsParameter) DefinitionsParameterOrReference {
	var s DefinitionsParameterOrReference
	s.SetDefinitionsParameter(v)
	return s
}

// SetDefinitionsReference sets DefinitionsParameterOrReference to DefinitionsReference.
func (s *DefinitionsParameterOrReference) SetDefinitionsReference(v DefinitionsReference) {
	s.Type = DefinitionsReferenceDefinitionsParameterOrReference
	s.DefinitionsReference = v
}

// GetDefinitionsReference returns DefinitionsReference and true boolean if DefinitionsParameterOrReference is DefinitionsReference.
func (s DefinitionsParameterOrReference) GetDefinitionsReference() (v DefinitionsReference, ok bool) {
	if !s.IsDefinitionsReference() {
		return v, false
	}
	return s.DefinitionsReference, true
}

// NewDefinitionsReferenceDefinitionsParameterOrReference returns new DefinitionsParameterOrReference from DefinitionsReference.
func NewDefinitionsReferenceDefinitionsParameterOrReference(v DefinitionsReference) DefinitionsParameterOrReference {
	var s DefinitionsParameterOrReference
	s.SetDefinitionsReference(v)
	return s
}

type DefinitionsParameterPattern0 map[string]jx.Raw

func (s *DefinitionsParameterPattern0) init() DefinitionsParameterPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsParameterStyle string

const (
	DefinitionsParameterStyleMatrix         DefinitionsParameterStyle = "matrix"
	DefinitionsParameterStyleLabel          DefinitionsParameterStyle = "label"
	DefinitionsParameterStyleForm           DefinitionsParameterStyle = "form"
	DefinitionsParameterStyleSimple         DefinitionsParameterStyle = "simple"
	DefinitionsParameterStyleSpaceDelimited DefinitionsParameterStyle = "spaceDelimited"
	DefinitionsParameterStylePipeDelimited  DefinitionsParameterStyle = "pipeDelimited"
	DefinitionsParameterStyleDeepObject     DefinitionsParameterStyle = "deepObject"
)

// Ref: #/definitions/parametersOrReferences
type DefinitionsParametersOrReferences map[string]DefinitionsParameterOrReference

func (s *DefinitionsParametersOrReferences) init() DefinitionsParametersOrReferences {
	m := *s
	if m == nil {
		m = map[string]DefinitionsParameterOrReference{}
		*s = m
	}
	return m
}

// Describes the operations available on a single path. A Path Item MAY be empty, due to ACL
// constraints. The path itself is still exposed to the documentation viewer but they will not know
// which operations and parameters are available.
// Ref: #/definitions/pathItem
type DefinitionsPathItem struct {
	Ref             OptString                         "json:\"$ref\""
	Summary         OptString                         "json:\"summary\""
	Description     OptString                         "json:\"description\""
	Get             OptDefinitionsOperation           "json:\"get\""
	Put             OptDefinitionsOperation           "json:\"put\""
	Post            OptDefinitionsOperation           "json:\"post\""
	Delete          OptDefinitionsOperation           "json:\"delete\""
	Options         OptDefinitionsOperation           "json:\"options\""
	Head            OptDefinitionsOperation           "json:\"head\""
	Patch           OptDefinitionsOperation           "json:\"patch\""
	Trace           OptDefinitionsOperation           "json:\"trace\""
	Servers         []DefinitionsServer               "json:\"servers\""
	Parameters      []DefinitionsParameterOrReference "json:\"parameters\""
	AdditionalProps DefinitionsPathItemAdditional
	Pattern0Props   DefinitionsPathItemPattern0
}

type DefinitionsPathItemAdditional map[string]jx.Raw

func (s *DefinitionsPathItemAdditional) init() DefinitionsPathItemAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsPathItemPattern0 map[string]jx.Raw

func (s *DefinitionsPathItemPattern0) init() DefinitionsPathItemPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Holds the relative paths to the individual endpoints and their operations. The path is appended to
// the URL from the `Server Object` in order to construct the full URL.  The Paths MAY be empty, due
// to ACL constraints.
// Ref: #/definitions/paths
type DefinitionsPaths struct {
	AdditionalProps DefinitionsPathsAdditional
	Pattern0Props   DefinitionsPathsPattern0
	Pattern1Props   DefinitionsPathsPattern1
}

type DefinitionsPathsAdditional map[string]jx.Raw

func (s *DefinitionsPathsAdditional) init() DefinitionsPathsAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsPathsPattern0 map[string]DefinitionsPathItem

func (s *DefinitionsPathsPattern0) init() DefinitionsPathsPattern0 {
	m := *s
	if m == nil {
		m = map[string]DefinitionsPathItem{}
		*s = m
	}
	return m
}

type DefinitionsPathsPattern1 map[string]jx.Raw

func (s *DefinitionsPathsPattern1) init() DefinitionsPathsPattern1 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsPositiveInteger int

// A simple object to allow referencing other components in the specification, internally and
// externally.  The Reference Object is defined by JSON Reference and follows the same structure,
// behavior and rules.   For this specification, reference resolution is accomplished as defined by
// the JSON Reference specification and not by the JSON Schema specification.
// Ref: #/definitions/reference
type DefinitionsReference struct {
	Ref             string "json:\"$ref\""
	AdditionalProps DefinitionsReferenceAdditional
}

type DefinitionsReferenceAdditional map[string]jx.Raw

func (s *DefinitionsReferenceAdditional) init() DefinitionsReferenceAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/requestBodiesOrReferences
type DefinitionsRequestBodiesOrReferences map[string]DefinitionsRequestBodyOrReference

func (s *DefinitionsRequestBodiesOrReferences) init() DefinitionsRequestBodiesOrReferences {
	m := *s
	if m == nil {
		m = map[string]DefinitionsRequestBodyOrReference{}
		*s = m
	}
	return m
}

// Describes a single request body.
// Ref: #/definitions/requestBody
type DefinitionsRequestBody struct {
	Description     OptString             "json:\"description\""
	Content         DefinitionsMediaTypes "json:\"content\""
	Required        OptBool               "json:\"required\""
	AdditionalProps DefinitionsRequestBodyAdditional
	Pattern0Props   DefinitionsRequestBodyPattern0
}

type DefinitionsRequestBodyAdditional map[string]jx.Raw

func (s *DefinitionsRequestBodyAdditional) init() DefinitionsRequestBodyAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/requestBodyOrReference
// DefinitionsRequestBodyOrReference represents sum type.
type DefinitionsRequestBodyOrReference struct {
	Type                   DefinitionsRequestBodyOrReferenceType // switch on this field
	DefinitionsRequestBody DefinitionsRequestBody
	DefinitionsReference   DefinitionsReference
}

// DefinitionsRequestBodyOrReferenceType is oneOf type of DefinitionsRequestBodyOrReference.
type DefinitionsRequestBodyOrReferenceType string

// Possible values for DefinitionsRequestBodyOrReferenceType.
const (
	DefinitionsRequestBodyDefinitionsRequestBodyOrReference DefinitionsRequestBodyOrReferenceType = "DefinitionsRequestBody"
	DefinitionsReferenceDefinitionsRequestBodyOrReference   DefinitionsRequestBodyOrReferenceType = "DefinitionsReference"
)

// IsDefinitionsRequestBody reports whether DefinitionsRequestBodyOrReference is DefinitionsRequestBody.
func (s DefinitionsRequestBodyOrReference) IsDefinitionsRequestBody() bool {
	return s.Type == DefinitionsRequestBodyDefinitionsRequestBodyOrReference
}

// IsDefinitionsReference reports whether DefinitionsRequestBodyOrReference is DefinitionsReference.
func (s DefinitionsRequestBodyOrReference) IsDefinitionsReference() bool {
	return s.Type == DefinitionsReferenceDefinitionsRequestBodyOrReference
}

// SetDefinitionsRequestBody sets DefinitionsRequestBodyOrReference to DefinitionsRequestBody.
func (s *DefinitionsRequestBodyOrReference) SetDefinitionsRequestBody(v DefinitionsRequestBody) {
	s.Type = DefinitionsRequestBodyDefinitionsRequestBodyOrReference
	s.DefinitionsRequestBody = v
}

// GetDefinitionsRequestBody returns DefinitionsRequestBody and true boolean if DefinitionsRequestBodyOrReference is DefinitionsRequestBody.
func (s DefinitionsRequestBodyOrReference) GetDefinitionsRequestBody() (v DefinitionsRequestBody, ok bool) {
	if !s.IsDefinitionsRequestBody() {
		return v, false
	}
	return s.DefinitionsRequestBody, true
}

// NewDefinitionsRequestBodyDefinitionsRequestBodyOrReference returns new DefinitionsRequestBodyOrReference from DefinitionsRequestBody.
func NewDefinitionsRequestBodyDefinitionsRequestBodyOrReference(v DefinitionsRequestBody) DefinitionsRequestBodyOrReference {
	var s DefinitionsRequestBodyOrReference
	s.SetDefinitionsRequestBody(v)
	return s
}

// SetDefinitionsReference sets DefinitionsRequestBodyOrReference to DefinitionsReference.
func (s *DefinitionsRequestBodyOrReference) SetDefinitionsReference(v DefinitionsReference) {
	s.Type = DefinitionsReferenceDefinitionsRequestBodyOrReference
	s.DefinitionsReference = v
}

// GetDefinitionsReference returns DefinitionsReference and true boolean if DefinitionsRequestBodyOrReference is DefinitionsReference.
func (s DefinitionsRequestBodyOrReference) GetDefinitionsReference() (v DefinitionsReference, ok bool) {
	if !s.IsDefinitionsReference() {
		return v, false
	}
	return s.DefinitionsReference, true
}

// NewDefinitionsReferenceDefinitionsRequestBodyOrReference returns new DefinitionsRequestBodyOrReference from DefinitionsReference.
func NewDefinitionsReferenceDefinitionsRequestBodyOrReference(v DefinitionsReference) DefinitionsRequestBodyOrReference {
	var s DefinitionsRequestBodyOrReference
	s.SetDefinitionsReference(v)
	return s
}

type DefinitionsRequestBodyPattern0 map[string]jx.Raw

func (s *DefinitionsRequestBodyPattern0) init() DefinitionsRequestBodyPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Describes a single response from an API Operation, including design-time, static  `links` to
// operations based on the response.
// Ref: #/definitions/response
type DefinitionsResponse struct {
	Description     string                            "json:\"description\""
	Headers         OptDefinitionsHeadersOrReferences "json:\"headers\""
	Content         OptDefinitionsMediaTypes          "json:\"content\""
	Links           OptDefinitionsLinksOrReferences   "json:\"links\""
	AdditionalProps DefinitionsResponseAdditional
	Pattern0Props   DefinitionsResponsePattern0
}

type DefinitionsResponseAdditional map[string]jx.Raw

func (s *DefinitionsResponseAdditional) init() DefinitionsResponseAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/responseOrReference
// DefinitionsResponseOrReference represents sum type.
type DefinitionsResponseOrReference struct {
	Type                 DefinitionsResponseOrReferenceType // switch on this field
	DefinitionsResponse  DefinitionsResponse
	DefinitionsReference DefinitionsReference
}

// DefinitionsResponseOrReferenceType is oneOf type of DefinitionsResponseOrReference.
type DefinitionsResponseOrReferenceType string

// Possible values for DefinitionsResponseOrReferenceType.
const (
	DefinitionsResponseDefinitionsResponseOrReference  DefinitionsResponseOrReferenceType = "DefinitionsResponse"
	DefinitionsReferenceDefinitionsResponseOrReference DefinitionsResponseOrReferenceType = "DefinitionsReference"
)

// IsDefinitionsResponse reports whether DefinitionsResponseOrReference is DefinitionsResponse.
func (s DefinitionsResponseOrReference) IsDefinitionsResponse() bool {
	return s.Type == DefinitionsResponseDefinitionsResponseOrReference
}

// IsDefinitionsReference reports whether DefinitionsResponseOrReference is DefinitionsReference.
func (s DefinitionsResponseOrReference) IsDefinitionsReference() bool {
	return s.Type == DefinitionsReferenceDefinitionsResponseOrReference
}

// SetDefinitionsResponse sets DefinitionsResponseOrReference to DefinitionsResponse.
func (s *DefinitionsResponseOrReference) SetDefinitionsResponse(v DefinitionsResponse) {
	s.Type = DefinitionsResponseDefinitionsResponseOrReference
	s.DefinitionsResponse = v
}

// GetDefinitionsResponse returns DefinitionsResponse and true boolean if DefinitionsResponseOrReference is DefinitionsResponse.
func (s DefinitionsResponseOrReference) GetDefinitionsResponse() (v DefinitionsResponse, ok bool) {
	if !s.IsDefinitionsResponse() {
		return v, false
	}
	return s.DefinitionsResponse, true
}

// NewDefinitionsResponseDefinitionsResponseOrReference returns new DefinitionsResponseOrReference from DefinitionsResponse.
func NewDefinitionsResponseDefinitionsResponseOrReference(v DefinitionsResponse) DefinitionsResponseOrReference {
	var s DefinitionsResponseOrReference
	s.SetDefinitionsResponse(v)
	return s
}

// SetDefinitionsReference sets DefinitionsResponseOrReference to DefinitionsReference.
func (s *DefinitionsResponseOrReference) SetDefinitionsReference(v DefinitionsReference) {
	s.Type = DefinitionsReferenceDefinitionsResponseOrReference
	s.DefinitionsReference = v
}

// GetDefinitionsReference returns DefinitionsReference and true boolean if DefinitionsResponseOrReference is DefinitionsReference.
func (s DefinitionsResponseOrReference) GetDefinitionsReference() (v DefinitionsReference, ok bool) {
	if !s.IsDefinitionsReference() {
		return v, false
	}
	return s.DefinitionsReference, true
}

// NewDefinitionsReferenceDefinitionsResponseOrReference returns new DefinitionsResponseOrReference from DefinitionsReference.
func NewDefinitionsReferenceDefinitionsResponseOrReference(v DefinitionsReference) DefinitionsResponseOrReference {
	var s DefinitionsResponseOrReference
	s.SetDefinitionsReference(v)
	return s
}

type DefinitionsResponsePattern0 map[string]jx.Raw

func (s *DefinitionsResponsePattern0) init() DefinitionsResponsePattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// A container for the expected responses of an operation. The container maps a HTTP response code to
// the expected response.  The documentation is not necessarily expected to cover all possible HTTP
// response codes because they may not be known in advance. However, documentation is expected to
// cover a successful operation response and any known errors.  The `default` MAY be used as a
// default response object for all HTTP codes  that are not covered individually by the specification.
//   The `Responses Object` MUST contain at least one response code, and it  SHOULD be the response
// for a successful operation call.
// Ref: #/definitions/responses
type DefinitionsResponses struct {
	Default         OptDefinitionsResponseOrReference "json:\"default\""
	AdditionalProps DefinitionsResponsesAdditional
	Pattern0Props   DefinitionsResponsesPattern0
	Pattern1Props   DefinitionsResponsesPattern1
}

type DefinitionsResponsesAdditional map[string]jx.Raw

func (s *DefinitionsResponsesAdditional) init() DefinitionsResponsesAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/responsesOrReferences
type DefinitionsResponsesOrReferences map[string]DefinitionsResponseOrReference

func (s *DefinitionsResponsesOrReferences) init() DefinitionsResponsesOrReferences {
	m := *s
	if m == nil {
		m = map[string]DefinitionsResponseOrReference{}
		*s = m
	}
	return m
}

type DefinitionsResponsesPattern0 map[string]DefinitionsResponseOrReference

func (s *DefinitionsResponsesPattern0) init() DefinitionsResponsesPattern0 {
	m := *s
	if m == nil {
		m = map[string]DefinitionsResponseOrReference{}
		*s = m
	}
	return m
}

type DefinitionsResponsesPattern1 map[string]jx.Raw

func (s *DefinitionsResponsesPattern1) init() DefinitionsResponsesPattern1 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// The Schema Object allows the definition of input and output data types. These types can be objects,
//  but also primitives and arrays. This object is an extended subset of the JSON Schema
// Specification Wright Draft 00.  For more information about the properties, see JSON Schema Core
// and JSON Schema Validation. Unless stated otherwise, the property definitions follow the JSON
// Schema.
// Ref: #/definitions/schema
type DefinitionsSchema struct {
	Nullable             OptBool                                                  "json:\"nullable\""
	Discriminator        OptDefinitionsDiscriminator                              "json:\"discriminator\""
	ReadOnly             OptBool                                                  "json:\"readOnly\""
	WriteOnly            OptBool                                                  "json:\"writeOnly\""
	XML                  OptDefinitionsXML                                        "json:\"xml\""
	ExternalDocs         OptDefinitionsExternalDocs                               "json:\"externalDocs\""
	Example              jx.Raw                                                   "json:\"example\""
	Deprecated           OptBool                                                  "json:\"deprecated\""
	Title                OptDefinitionsJsonschemaDraft4PropertiesTitle            "json:\"title\""
	MultipleOf           OptDefinitionsJsonschemaDraft4PropertiesMultipleOf       "json:\"multipleOf\""
	Maximum              OptDefinitionsJsonschemaDraft4PropertiesMaximum          "json:\"maximum\""
	ExclusiveMaximum     OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum "json:\"exclusiveMaximum\""
	Minimum              OptDefinitionsJsonschemaDraft4PropertiesMinimum          "json:\"minimum\""
	ExclusiveMinimum     OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum "json:\"exclusiveMinimum\""
	MaxLength            OptDefinitionsPositiveInteger                            "json:\"maxLength\""
	MinLength            OptDefinitionsPositiveInteger                            "json:\"minLength\""
	Pattern              OptDefinitionsJsonschemaDraft4PropertiesPattern          "json:\"pattern\""
	MaxItems             OptDefinitionsPositiveInteger                            "json:\"maxItems\""
	MinItems             OptDefinitionsPositiveInteger                            "json:\"minItems\""
	UniqueItems          OptDefinitionsJsonschemaDraft4PropertiesUniqueItems      "json:\"uniqueItems\""
	MaxProperties        OptDefinitionsPositiveInteger                            "json:\"maxProperties\""
	MinProperties        OptDefinitionsPositiveInteger                            "json:\"minProperties\""
	Required             *DefinitionsStringArray                                  "json:\"required\""
	Enum                 *DefinitionsJsonschemaDraft4PropertiesEnum               "json:\"enum\""
	Type                 OptDefinitionsSchemaType                                 "json:\"type\""
	AllOf                []DefinitionsSchemaOrReference                           "json:\"allOf\""
	OneOf                []DefinitionsSchemaOrReference                           "json:\"oneOf\""
	AnyOf                []DefinitionsSchemaOrReference                           "json:\"anyOf\""
	Not                  *DefinitionsSchema                                       "json:\"not\""
	Items                *DefinitionsSchemaOrReference                            "json:\"items\""
	Properties           OptDefinitionsSchemaProperties                           "json:\"properties\""
	AdditionalProperties *DefinitionsSchemaAdditionalProperties                   "json:\"additionalProperties\""
	Default              jx.Raw                                                   "json:\"default\""
	Description          OptString                                                "json:\"description\""
	Format               OptString                                                "json:\"format\""
	AdditionalProps      DefinitionsSchemaAdditional
	Pattern0Props        DefinitionsSchemaPattern0
}

type DefinitionsSchemaAdditional map[string]jx.Raw

func (s *DefinitionsSchemaAdditional) init() DefinitionsSchemaAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// DefinitionsSchemaAdditionalProperties represents sum type.
type DefinitionsSchemaAdditionalProperties struct {
	Type                         DefinitionsSchemaAdditionalPropertiesType // switch on this field
	DefinitionsSchemaOrReference DefinitionsSchemaOrReference
	Bool                         bool
}

// DefinitionsSchemaAdditionalPropertiesType is oneOf type of DefinitionsSchemaAdditionalProperties.
type DefinitionsSchemaAdditionalPropertiesType string

// Possible values for DefinitionsSchemaAdditionalPropertiesType.
const (
	DefinitionsSchemaOrReferenceDefinitionsSchemaAdditionalProperties DefinitionsSchemaAdditionalPropertiesType = "DefinitionsSchemaOrReference"
	BoolDefinitionsSchemaAdditionalProperties                         DefinitionsSchemaAdditionalPropertiesType = "bool"
)

// IsDefinitionsSchemaOrReference reports whether DefinitionsSchemaAdditionalProperties is DefinitionsSchemaOrReference.
func (s DefinitionsSchemaAdditionalProperties) IsDefinitionsSchemaOrReference() bool {
	return s.Type == DefinitionsSchemaOrReferenceDefinitionsSchemaAdditionalProperties
}

// IsBool reports whether DefinitionsSchemaAdditionalProperties is bool.
func (s DefinitionsSchemaAdditionalProperties) IsBool() bool {
	return s.Type == BoolDefinitionsSchemaAdditionalProperties
}

// SetDefinitionsSchemaOrReference sets DefinitionsSchemaAdditionalProperties to DefinitionsSchemaOrReference.
func (s *DefinitionsSchemaAdditionalProperties) SetDefinitionsSchemaOrReference(v DefinitionsSchemaOrReference) {
	s.Type = DefinitionsSchemaOrReferenceDefinitionsSchemaAdditionalProperties
	s.DefinitionsSchemaOrReference = v
}

// GetDefinitionsSchemaOrReference returns DefinitionsSchemaOrReference and true boolean if DefinitionsSchemaAdditionalProperties is DefinitionsSchemaOrReference.
func (s DefinitionsSchemaAdditionalProperties) GetDefinitionsSchemaOrReference() (v DefinitionsSchemaOrReference, ok bool) {
	if !s.IsDefinitionsSchemaOrReference() {
		return v, false
	}
	return s.DefinitionsSchemaOrReference, true
}

// NewDefinitionsSchemaOrReferenceDefinitionsSchemaAdditionalProperties returns new DefinitionsSchemaAdditionalProperties from DefinitionsSchemaOrReference.
func NewDefinitionsSchemaOrReferenceDefinitionsSchemaAdditionalProperties(v DefinitionsSchemaOrReference) DefinitionsSchemaAdditionalProperties {
	var s DefinitionsSchemaAdditionalProperties
	s.SetDefinitionsSchemaOrReference(v)
	return s
}

// SetBool sets DefinitionsSchemaAdditionalProperties to bool.
func (s *DefinitionsSchemaAdditionalProperties) SetBool(v bool) {
	s.Type = BoolDefinitionsSchemaAdditionalProperties
	s.Bool = v
}

// GetBool returns bool and true boolean if DefinitionsSchemaAdditionalProperties is bool.
func (s DefinitionsSchemaAdditionalProperties) GetBool() (v bool, ok bool) {
	if !s.IsBool() {
		return v, false
	}
	return s.Bool, true
}

// NewBoolDefinitionsSchemaAdditionalProperties returns new DefinitionsSchemaAdditionalProperties from bool.
func NewBoolDefinitionsSchemaAdditionalProperties(v bool) DefinitionsSchemaAdditionalProperties {
	var s DefinitionsSchemaAdditionalProperties
	s.SetBool(v)
	return s
}

// Ref: #/definitions/schemaOrReference
// DefinitionsSchemaOrReference represents sum type.
type DefinitionsSchemaOrReference struct {
	Type                 DefinitionsSchemaOrReferenceType // switch on this field
	DefinitionsSchema    DefinitionsSchema
	DefinitionsReference DefinitionsReference
}

// DefinitionsSchemaOrReferenceType is oneOf type of DefinitionsSchemaOrReference.
type DefinitionsSchemaOrReferenceType string

// Possible values for DefinitionsSchemaOrReferenceType.
const (
	DefinitionsSchemaDefinitionsSchemaOrReference    DefinitionsSchemaOrReferenceType = "DefinitionsSchema"
	DefinitionsReferenceDefinitionsSchemaOrReference DefinitionsSchemaOrReferenceType = "DefinitionsReference"
)

// IsDefinitionsSchema reports whether DefinitionsSchemaOrReference is DefinitionsSchema.
func (s DefinitionsSchemaOrReference) IsDefinitionsSchema() bool {
	return s.Type == DefinitionsSchemaDefinitionsSchemaOrReference
}

// IsDefinitionsReference reports whether DefinitionsSchemaOrReference is DefinitionsReference.
func (s DefinitionsSchemaOrReference) IsDefinitionsReference() bool {
	return s.Type == DefinitionsReferenceDefinitionsSchemaOrReference
}

// SetDefinitionsSchema sets DefinitionsSchemaOrReference to DefinitionsSchema.
func (s *DefinitionsSchemaOrReference) SetDefinitionsSchema(v DefinitionsSchema) {
	s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
	s.DefinitionsSchema = v
}

// GetDefinitionsSchema returns DefinitionsSchema and true boolean if DefinitionsSchemaOrReference is DefinitionsSchema.
func (s DefinitionsSchemaOrReference) GetDefinitionsSchema() (v DefinitionsSchema, ok bool) {
	if !s.IsDefinitionsSchema() {
		return v, false
	}
	return s.DefinitionsSchema, true
}

// NewDefinitionsSchemaDefinitionsSchemaOrReference returns new DefinitionsSchemaOrReference from DefinitionsSchema.
func NewDefinitionsSchemaDefinitionsSchemaOrReference(v DefinitionsSchema) DefinitionsSchemaOrReference {
	var s DefinitionsSchemaOrReference
	s.SetDefinitionsSchema(v)
	return s
}

// SetDefinitionsReference sets DefinitionsSchemaOrReference to DefinitionsReference.
func (s *DefinitionsSchemaOrReference) SetDefinitionsReference(v DefinitionsReference) {
	s.Type = DefinitionsReferenceDefinitionsSchemaOrReference
	s.DefinitionsReference = v
}

// GetDefinitionsReference returns DefinitionsReference and true boolean if DefinitionsSchemaOrReference is DefinitionsReference.
func (s DefinitionsSchemaOrReference) GetDefinitionsReference() (v DefinitionsReference, ok bool) {
	if !s.IsDefinitionsReference() {
		return v, false
	}
	return s.DefinitionsReference, true
}

// NewDefinitionsReferenceDefinitionsSchemaOrReference returns new DefinitionsSchemaOrReference from DefinitionsReference.
func NewDefinitionsReferenceDefinitionsSchemaOrReference(v DefinitionsReference) DefinitionsSchemaOrReference {
	var s DefinitionsSchemaOrReference
	s.SetDefinitionsReference(v)
	return s
}

type DefinitionsSchemaPattern0 map[string]jx.Raw

func (s *DefinitionsSchemaPattern0) init() DefinitionsSchemaPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsSchemaProperties map[string]DefinitionsSchemaOrReference

func (s *DefinitionsSchemaProperties) init() DefinitionsSchemaProperties {
	m := *s
	if m == nil {
		m = map[string]DefinitionsSchemaOrReference{}
		*s = m
	}
	return m
}

type DefinitionsSchemaType string

const (
	DefinitionsSchemaTypeArray   DefinitionsSchemaType = "array"
	DefinitionsSchemaTypeBoolean DefinitionsSchemaType = "boolean"
	DefinitionsSchemaTypeInteger DefinitionsSchemaType = "integer"
	DefinitionsSchemaTypeNull    DefinitionsSchemaType = "null"
	DefinitionsSchemaTypeNumber  DefinitionsSchemaType = "number"
	DefinitionsSchemaTypeObject  DefinitionsSchemaType = "object"
	DefinitionsSchemaTypeString  DefinitionsSchemaType = "string"
)

// Ref: #/definitions/schemasOrReferences
type DefinitionsSchemasOrReferences map[string]DefinitionsSchemaOrReference

func (s *DefinitionsSchemasOrReferences) init() DefinitionsSchemasOrReferences {
	m := *s
	if m == nil {
		m = map[string]DefinitionsSchemaOrReference{}
		*s = m
	}
	return m
}

// Lists the required security schemes to execute this operation. The name used for each property
// MUST correspond to a security scheme declared in the Security Schemes under the Components Object.
//  Security Requirement Objects that contain multiple schemes require that all schemes MUST be
// satisfied for a request to be authorized. This enables support for scenarios where multiple query
// parameters or HTTP headers are required to convey security information.  When a list of Security
// Requirement Objects is defined on the Open API object or Operation Object, only one of Security
// Requirement Objects in the list needs to be satisfied to authorize the request.
// Ref: #/definitions/securityRequirement
type DefinitionsSecurityRequirement struct {
	AdditionalProps DefinitionsSecurityRequirementAdditional
	Pattern0Props   DefinitionsSecurityRequirementPattern0
}

type DefinitionsSecurityRequirementAdditional map[string]jx.Raw

func (s *DefinitionsSecurityRequirementAdditional) init() DefinitionsSecurityRequirementAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsSecurityRequirementPattern0 map[string][]string

func (s *DefinitionsSecurityRequirementPattern0) init() DefinitionsSecurityRequirementPattern0 {
	m := *s
	if m == nil {
		m = map[string][]string{}
		*s = m
	}
	return m
}

// Defines a security scheme that can be used by the operations. Supported schemes are HTTP
// authentication, an API key (either as a header or as a query parameter), OAuth2's common flows
// (implicit, password, application and access code) as defined in RFC6749, and OpenID Connect
// Discovery.
// Ref: #/definitions/securityScheme
type DefinitionsSecurityScheme struct {
	Type             string                   "json:\"type\""
	Description      OptString                "json:\"description\""
	Name             OptString                "json:\"name\""
	In               OptString                "json:\"in\""
	Scheme           OptString                "json:\"scheme\""
	BearerFormat     OptString                "json:\"bearerFormat\""
	Flows            OptDefinitionsOauthFlows "json:\"flows\""
	OpenIdConnectUrl OptString                "json:\"openIdConnectUrl\""
	AdditionalProps  DefinitionsSecuritySchemeAdditional
	Pattern0Props    DefinitionsSecuritySchemePattern0
}

type DefinitionsSecuritySchemeAdditional map[string]jx.Raw

func (s *DefinitionsSecuritySchemeAdditional) init() DefinitionsSecuritySchemeAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/securitySchemeOrReference
// DefinitionsSecuritySchemeOrReference represents sum type.
type DefinitionsSecuritySchemeOrReference struct {
	Type                      DefinitionsSecuritySchemeOrReferenceType // switch on this field
	DefinitionsSecurityScheme DefinitionsSecurityScheme
	DefinitionsReference      DefinitionsReference
}

// DefinitionsSecuritySchemeOrReferenceType is oneOf type of DefinitionsSecuritySchemeOrReference.
type DefinitionsSecuritySchemeOrReferenceType string

// Possible values for DefinitionsSecuritySchemeOrReferenceType.
const (
	DefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference DefinitionsSecuritySchemeOrReferenceType = "DefinitionsSecurityScheme"
	DefinitionsReferenceDefinitionsSecuritySchemeOrReference      DefinitionsSecuritySchemeOrReferenceType = "DefinitionsReference"
)

// IsDefinitionsSecurityScheme reports whether DefinitionsSecuritySchemeOrReference is DefinitionsSecurityScheme.
func (s DefinitionsSecuritySchemeOrReference) IsDefinitionsSecurityScheme() bool {
	return s.Type == DefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference
}

// IsDefinitionsReference reports whether DefinitionsSecuritySchemeOrReference is DefinitionsReference.
func (s DefinitionsSecuritySchemeOrReference) IsDefinitionsReference() bool {
	return s.Type == DefinitionsReferenceDefinitionsSecuritySchemeOrReference
}

// SetDefinitionsSecurityScheme sets DefinitionsSecuritySchemeOrReference to DefinitionsSecurityScheme.
func (s *DefinitionsSecuritySchemeOrReference) SetDefinitionsSecurityScheme(v DefinitionsSecurityScheme) {
	s.Type = DefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference
	s.DefinitionsSecurityScheme = v
}

// GetDefinitionsSecurityScheme returns DefinitionsSecurityScheme and true boolean if DefinitionsSecuritySchemeOrReference is DefinitionsSecurityScheme.
func (s DefinitionsSecuritySchemeOrReference) GetDefinitionsSecurityScheme() (v DefinitionsSecurityScheme, ok bool) {
	if !s.IsDefinitionsSecurityScheme() {
		return v, false
	}
	return s.DefinitionsSecurityScheme, true
}

// NewDefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference returns new DefinitionsSecuritySchemeOrReference from DefinitionsSecurityScheme.
func NewDefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference(v DefinitionsSecurityScheme) DefinitionsSecuritySchemeOrReference {
	var s DefinitionsSecuritySchemeOrReference
	s.SetDefinitionsSecurityScheme(v)
	return s
}

// SetDefinitionsReference sets DefinitionsSecuritySchemeOrReference to DefinitionsReference.
func (s *DefinitionsSecuritySchemeOrReference) SetDefinitionsReference(v DefinitionsReference) {
	s.Type = DefinitionsReferenceDefinitionsSecuritySchemeOrReference
	s.DefinitionsReference = v
}

// GetDefinitionsReference returns DefinitionsReference and true boolean if DefinitionsSecuritySchemeOrReference is DefinitionsReference.
func (s DefinitionsSecuritySchemeOrReference) GetDefinitionsReference() (v DefinitionsReference, ok bool) {
	if !s.IsDefinitionsReference() {
		return v, false
	}
	return s.DefinitionsReference, true
}

// NewDefinitionsReferenceDefinitionsSecuritySchemeOrReference returns new DefinitionsSecuritySchemeOrReference from DefinitionsReference.
func NewDefinitionsReferenceDefinitionsSecuritySchemeOrReference(v DefinitionsReference) DefinitionsSecuritySchemeOrReference {
	var s DefinitionsSecuritySchemeOrReference
	s.SetDefinitionsReference(v)
	return s
}

type DefinitionsSecuritySchemePattern0 map[string]jx.Raw

func (s *DefinitionsSecuritySchemePattern0) init() DefinitionsSecuritySchemePattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/securitySchemesOrReferences
type DefinitionsSecuritySchemesOrReferences map[string]DefinitionsSecuritySchemeOrReference

func (s *DefinitionsSecuritySchemesOrReferences) init() DefinitionsSecuritySchemesOrReferences {
	m := *s
	if m == nil {
		m = map[string]DefinitionsSecuritySchemeOrReference{}
		*s = m
	}
	return m
}

// An object representing a Server.
// Ref: #/definitions/server
type DefinitionsServer struct {
	URL             string                        "json:\"url\""
	Description     OptString                     "json:\"description\""
	Variables       OptDefinitionsServerVariables "json:\"variables\""
	AdditionalProps DefinitionsServerAdditional
	Pattern0Props   DefinitionsServerPattern0
}

type DefinitionsServerAdditional map[string]jx.Raw

func (s *DefinitionsServerAdditional) init() DefinitionsServerAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsServerPattern0 map[string]jx.Raw

func (s *DefinitionsServerPattern0) init() DefinitionsServerPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// An object representing a Server Variable for server URL template substitution.
// Ref: #/definitions/serverVariable
type DefinitionsServerVariable struct {
	Enum            []string  "json:\"enum\""
	Default         string    "json:\"default\""
	Description     OptString "json:\"description\""
	AdditionalProps DefinitionsServerVariableAdditional
	Pattern0Props   DefinitionsServerVariablePattern0
}

type DefinitionsServerVariableAdditional map[string]jx.Raw

func (s *DefinitionsServerVariableAdditional) init() DefinitionsServerVariableAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsServerVariablePattern0 map[string]jx.Raw

func (s *DefinitionsServerVariablePattern0) init() DefinitionsServerVariablePattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// Ref: #/definitions/serverVariables
type DefinitionsServerVariables map[string]DefinitionsServerVariable

func (s *DefinitionsServerVariables) init() DefinitionsServerVariables {
	m := *s
	if m == nil {
		m = map[string]DefinitionsServerVariable{}
		*s = m
	}
	return m
}

type DefinitionsStringArray []string

// Ref: #/definitions/strings
type DefinitionsStrings map[string]string

func (s *DefinitionsStrings) init() DefinitionsStrings {
	m := *s
	if m == nil {
		m = map[string]string{}
		*s = m
	}
	return m
}

// Adds metadata to a single tag that is used by the Operation Object. It is not mandatory to have a
// Tag Object per tag defined in the Operation Object instances.
// Ref: #/definitions/tag
type DefinitionsTag struct {
	Name            string                     "json:\"name\""
	Description     OptString                  "json:\"description\""
	ExternalDocs    OptDefinitionsExternalDocs "json:\"externalDocs\""
	AdditionalProps DefinitionsTagAdditional
	Pattern0Props   DefinitionsTagPattern0
}

type DefinitionsTagAdditional map[string]jx.Raw

func (s *DefinitionsTagAdditional) init() DefinitionsTagAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsTagPattern0 map[string]jx.Raw

func (s *DefinitionsTagPattern0) init() DefinitionsTagPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// A metadata object that allows for more fine-tuned XML model definitions.  When using arrays, XML
// element names are *not* inferred (for singular/plural forms) and the `name` property SHOULD be
// used to add that information. See examples for expected behavior.
// Ref: #/definitions/xml
type DefinitionsXML struct {
	Name            OptString "json:\"name\""
	Namespace       OptString "json:\"namespace\""
	Prefix          OptString "json:\"prefix\""
	Attribute       OptBool   "json:\"attribute\""
	Wrapped         OptBool   "json:\"wrapped\""
	AdditionalProps DefinitionsXMLAdditional
	Pattern0Props   DefinitionsXMLPattern0
}

type DefinitionsXMLAdditional map[string]jx.Raw

func (s *DefinitionsXMLAdditional) init() DefinitionsXMLAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type DefinitionsXMLPattern0 map[string]jx.Raw

func (s *DefinitionsXMLPattern0) init() DefinitionsXMLPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// NewOptBool returns new OptBool with value set to v.
func NewOptBool(v bool) OptBool {
	return OptBool{
		Value: v,
		Set:   true,
	}
}

// OptBool is optional bool.
type OptBool struct {
	Value bool
	Set   bool
}

// IsSet returns true if OptBool was set.
func (o OptBool) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptBool) Reset() {
	var v bool
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptBool) SetTo(v bool) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptBool) Get() (v bool, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptBool) Or(d bool) bool {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsAnysOrExpressions returns new OptDefinitionsAnysOrExpressions with value set to v.
func NewOptDefinitionsAnysOrExpressions(v DefinitionsAnysOrExpressions) OptDefinitionsAnysOrExpressions {
	return OptDefinitionsAnysOrExpressions{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsAnysOrExpressions is optional DefinitionsAnysOrExpressions.
type OptDefinitionsAnysOrExpressions struct {
	Value DefinitionsAnysOrExpressions
	Set   bool
}

// IsSet returns true if OptDefinitionsAnysOrExpressions was set.
func (o OptDefinitionsAnysOrExpressions) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsAnysOrExpressions) Reset() {
	var v DefinitionsAnysOrExpressions
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsAnysOrExpressions) SetTo(v DefinitionsAnysOrExpressions) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsAnysOrExpressions) Get() (v DefinitionsAnysOrExpressions, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsAnysOrExpressions) Or(d DefinitionsAnysOrExpressions) DefinitionsAnysOrExpressions {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsCallbacksOrReferences returns new OptDefinitionsCallbacksOrReferences with value set to v.
func NewOptDefinitionsCallbacksOrReferences(v DefinitionsCallbacksOrReferences) OptDefinitionsCallbacksOrReferences {
	return OptDefinitionsCallbacksOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsCallbacksOrReferences is optional DefinitionsCallbacksOrReferences.
type OptDefinitionsCallbacksOrReferences struct {
	Value DefinitionsCallbacksOrReferences
	Set   bool
}

// IsSet returns true if OptDefinitionsCallbacksOrReferences was set.
func (o OptDefinitionsCallbacksOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsCallbacksOrReferences) Reset() {
	var v DefinitionsCallbacksOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsCallbacksOrReferences) SetTo(v DefinitionsCallbacksOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsCallbacksOrReferences) Get() (v DefinitionsCallbacksOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsCallbacksOrReferences) Or(d DefinitionsCallbacksOrReferences) DefinitionsCallbacksOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsComponents returns new OptDefinitionsComponents with value set to v.
func NewOptDefinitionsComponents(v DefinitionsComponents) OptDefinitionsComponents {
	return OptDefinitionsComponents{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsComponents is optional DefinitionsComponents.
type OptDefinitionsComponents struct {
	Value DefinitionsComponents
	Set   bool
}

// IsSet returns true if OptDefinitionsComponents was set.
func (o OptDefinitionsComponents) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsComponents) Reset() {
	var v DefinitionsComponents
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsComponents) SetTo(v DefinitionsComponents) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsComponents) Get() (v DefinitionsComponents, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsComponents) Or(d DefinitionsComponents) DefinitionsComponents {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsContact returns new OptDefinitionsContact with value set to v.
func NewOptDefinitionsContact(v DefinitionsContact) OptDefinitionsContact {
	return OptDefinitionsContact{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsContact is optional DefinitionsContact.
type OptDefinitionsContact struct {
	Value DefinitionsContact
	Set   bool
}

// IsSet returns true if OptDefinitionsContact was set.
func (o OptDefinitionsContact) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsContact) Reset() {
	var v DefinitionsContact
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsContact) SetTo(v DefinitionsContact) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsContact) Get() (v DefinitionsContact, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsContact) Or(d DefinitionsContact) DefinitionsContact {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsDiscriminator returns new OptDefinitionsDiscriminator with value set to v.
func NewOptDefinitionsDiscriminator(v DefinitionsDiscriminator) OptDefinitionsDiscriminator {
	return OptDefinitionsDiscriminator{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsDiscriminator is optional DefinitionsDiscriminator.
type OptDefinitionsDiscriminator struct {
	Value DefinitionsDiscriminator
	Set   bool
}

// IsSet returns true if OptDefinitionsDiscriminator was set.
func (o OptDefinitionsDiscriminator) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsDiscriminator) Reset() {
	var v DefinitionsDiscriminator
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsDiscriminator) SetTo(v DefinitionsDiscriminator) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsDiscriminator) Get() (v DefinitionsDiscriminator, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsDiscriminator) Or(d DefinitionsDiscriminator) DefinitionsDiscriminator {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsEncodings returns new OptDefinitionsEncodings with value set to v.
func NewOptDefinitionsEncodings(v DefinitionsEncodings) OptDefinitionsEncodings {
	return OptDefinitionsEncodings{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsEncodings is optional DefinitionsEncodings.
type OptDefinitionsEncodings struct {
	Value DefinitionsEncodings
	Set   bool
}

// IsSet returns true if OptDefinitionsEncodings was set.
func (o OptDefinitionsEncodings) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsEncodings) Reset() {
	var v DefinitionsEncodings
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsEncodings) SetTo(v DefinitionsEncodings) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsEncodings) Get() (v DefinitionsEncodings, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsEncodings) Or(d DefinitionsEncodings) DefinitionsEncodings {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsExamplesOrReferences returns new OptDefinitionsExamplesOrReferences with value set to v.
func NewOptDefinitionsExamplesOrReferences(v DefinitionsExamplesOrReferences) OptDefinitionsExamplesOrReferences {
	return OptDefinitionsExamplesOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsExamplesOrReferences is optional DefinitionsExamplesOrReferences.
type OptDefinitionsExamplesOrReferences struct {
	Value DefinitionsExamplesOrReferences
	Set   bool
}

// IsSet returns true if OptDefinitionsExamplesOrReferences was set.
func (o OptDefinitionsExamplesOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsExamplesOrReferences) Reset() {
	var v DefinitionsExamplesOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsExamplesOrReferences) SetTo(v DefinitionsExamplesOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsExamplesOrReferences) Get() (v DefinitionsExamplesOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsExamplesOrReferences) Or(d DefinitionsExamplesOrReferences) DefinitionsExamplesOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsExternalDocs returns new OptDefinitionsExternalDocs with value set to v.
func NewOptDefinitionsExternalDocs(v DefinitionsExternalDocs) OptDefinitionsExternalDocs {
	return OptDefinitionsExternalDocs{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsExternalDocs is optional DefinitionsExternalDocs.
type OptDefinitionsExternalDocs struct {
	Value DefinitionsExternalDocs
	Set   bool
}

// IsSet returns true if OptDefinitionsExternalDocs was set.
func (o OptDefinitionsExternalDocs) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsExternalDocs) Reset() {
	var v DefinitionsExternalDocs
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsExternalDocs) SetTo(v DefinitionsExternalDocs) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsExternalDocs) Get() (v DefinitionsExternalDocs, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsExternalDocs) Or(d DefinitionsExternalDocs) DefinitionsExternalDocs {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsHeadersOrReferences returns new OptDefinitionsHeadersOrReferences with value set to v.
func NewOptDefinitionsHeadersOrReferences(v DefinitionsHeadersOrReferences) OptDefinitionsHeadersOrReferences {
	return OptDefinitionsHeadersOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsHeadersOrReferences is optional DefinitionsHeadersOrReferences.
type OptDefinitionsHeadersOrReferences struct {
	Value DefinitionsHeadersOrReferences
	Set   bool
}

// IsSet returns true if OptDefinitionsHeadersOrReferences was set.
func (o OptDefinitionsHeadersOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsHeadersOrReferences) Reset() {
	var v DefinitionsHeadersOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsHeadersOrReferences) SetTo(v DefinitionsHeadersOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsHeadersOrReferences) Get() (v DefinitionsHeadersOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsHeadersOrReferences) Or(d DefinitionsHeadersOrReferences) DefinitionsHeadersOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum returns new OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum with value set to v.
func NewOptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum(v DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum {
	return OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum is optional DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum.
type OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum struct {
	Value DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum
	Set   bool
}

// IsSet returns true if OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) Reset() {
	var v DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) SetTo(v DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) Get() (v DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) Or(d DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum returns new OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum with value set to v.
func NewOptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum(v DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum {
	return OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum is optional DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum.
type OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum struct {
	Value DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum
	Set   bool
}

// IsSet returns true if OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) Reset() {
	var v DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) SetTo(v DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) Get() (v DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) Or(d DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsJsonschemaDraft4PropertiesMaximum returns new OptDefinitionsJsonschemaDraft4PropertiesMaximum with value set to v.
func NewOptDefinitionsJsonschemaDraft4PropertiesMaximum(v DefinitionsJsonschemaDraft4PropertiesMaximum) OptDefinitionsJsonschemaDraft4PropertiesMaximum {
	return OptDefinitionsJsonschemaDraft4PropertiesMaximum{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsJsonschemaDraft4PropertiesMaximum is optional DefinitionsJsonschemaDraft4PropertiesMaximum.
type OptDefinitionsJsonschemaDraft4PropertiesMaximum struct {
	Value DefinitionsJsonschemaDraft4PropertiesMaximum
	Set   bool
}

// IsSet returns true if OptDefinitionsJsonschemaDraft4PropertiesMaximum was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesMaximum) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsJsonschemaDraft4PropertiesMaximum) Reset() {
	var v DefinitionsJsonschemaDraft4PropertiesMaximum
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsJsonschemaDraft4PropertiesMaximum) SetTo(v DefinitionsJsonschemaDraft4PropertiesMaximum) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesMaximum) Get() (v DefinitionsJsonschemaDraft4PropertiesMaximum, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsJsonschemaDraft4PropertiesMaximum) Or(d DefinitionsJsonschemaDraft4PropertiesMaximum) DefinitionsJsonschemaDraft4PropertiesMaximum {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsJsonschemaDraft4PropertiesMinimum returns new OptDefinitionsJsonschemaDraft4PropertiesMinimum with value set to v.
func NewOptDefinitionsJsonschemaDraft4PropertiesMinimum(v DefinitionsJsonschemaDraft4PropertiesMinimum) OptDefinitionsJsonschemaDraft4PropertiesMinimum {
	return OptDefinitionsJsonschemaDraft4PropertiesMinimum{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsJsonschemaDraft4PropertiesMinimum is optional DefinitionsJsonschemaDraft4PropertiesMinimum.
type OptDefinitionsJsonschemaDraft4PropertiesMinimum struct {
	Value DefinitionsJsonschemaDraft4PropertiesMinimum
	Set   bool
}

// IsSet returns true if OptDefinitionsJsonschemaDraft4PropertiesMinimum was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesMinimum) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsJsonschemaDraft4PropertiesMinimum) Reset() {
	var v DefinitionsJsonschemaDraft4PropertiesMinimum
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsJsonschemaDraft4PropertiesMinimum) SetTo(v DefinitionsJsonschemaDraft4PropertiesMinimum) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesMinimum) Get() (v DefinitionsJsonschemaDraft4PropertiesMinimum, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsJsonschemaDraft4PropertiesMinimum) Or(d DefinitionsJsonschemaDraft4PropertiesMinimum) DefinitionsJsonschemaDraft4PropertiesMinimum {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsJsonschemaDraft4PropertiesMultipleOf returns new OptDefinitionsJsonschemaDraft4PropertiesMultipleOf with value set to v.
func NewOptDefinitionsJsonschemaDraft4PropertiesMultipleOf(v DefinitionsJsonschemaDraft4PropertiesMultipleOf) OptDefinitionsJsonschemaDraft4PropertiesMultipleOf {
	return OptDefinitionsJsonschemaDraft4PropertiesMultipleOf{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsJsonschemaDraft4PropertiesMultipleOf is optional DefinitionsJsonschemaDraft4PropertiesMultipleOf.
type OptDefinitionsJsonschemaDraft4PropertiesMultipleOf struct {
	Value DefinitionsJsonschemaDraft4PropertiesMultipleOf
	Set   bool
}

// IsSet returns true if OptDefinitionsJsonschemaDraft4PropertiesMultipleOf was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesMultipleOf) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsJsonschemaDraft4PropertiesMultipleOf) Reset() {
	var v DefinitionsJsonschemaDraft4PropertiesMultipleOf
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsJsonschemaDraft4PropertiesMultipleOf) SetTo(v DefinitionsJsonschemaDraft4PropertiesMultipleOf) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesMultipleOf) Get() (v DefinitionsJsonschemaDraft4PropertiesMultipleOf, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsJsonschemaDraft4PropertiesMultipleOf) Or(d DefinitionsJsonschemaDraft4PropertiesMultipleOf) DefinitionsJsonschemaDraft4PropertiesMultipleOf {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsJsonschemaDraft4PropertiesPattern returns new OptDefinitionsJsonschemaDraft4PropertiesPattern with value set to v.
func NewOptDefinitionsJsonschemaDraft4PropertiesPattern(v DefinitionsJsonschemaDraft4PropertiesPattern) OptDefinitionsJsonschemaDraft4PropertiesPattern {
	return OptDefinitionsJsonschemaDraft4PropertiesPattern{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsJsonschemaDraft4PropertiesPattern is optional DefinitionsJsonschemaDraft4PropertiesPattern.
type OptDefinitionsJsonschemaDraft4PropertiesPattern struct {
	Value DefinitionsJsonschemaDraft4PropertiesPattern
	Set   bool
}

// IsSet returns true if OptDefinitionsJsonschemaDraft4PropertiesPattern was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesPattern) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsJsonschemaDraft4PropertiesPattern) Reset() {
	var v DefinitionsJsonschemaDraft4PropertiesPattern
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsJsonschemaDraft4PropertiesPattern) SetTo(v DefinitionsJsonschemaDraft4PropertiesPattern) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesPattern) Get() (v DefinitionsJsonschemaDraft4PropertiesPattern, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsJsonschemaDraft4PropertiesPattern) Or(d DefinitionsJsonschemaDraft4PropertiesPattern) DefinitionsJsonschemaDraft4PropertiesPattern {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsJsonschemaDraft4PropertiesTitle returns new OptDefinitionsJsonschemaDraft4PropertiesTitle with value set to v.
func NewOptDefinitionsJsonschemaDraft4PropertiesTitle(v DefinitionsJsonschemaDraft4PropertiesTitle) OptDefinitionsJsonschemaDraft4PropertiesTitle {
	return OptDefinitionsJsonschemaDraft4PropertiesTitle{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsJsonschemaDraft4PropertiesTitle is optional DefinitionsJsonschemaDraft4PropertiesTitle.
type OptDefinitionsJsonschemaDraft4PropertiesTitle struct {
	Value DefinitionsJsonschemaDraft4PropertiesTitle
	Set   bool
}

// IsSet returns true if OptDefinitionsJsonschemaDraft4PropertiesTitle was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesTitle) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsJsonschemaDraft4PropertiesTitle) Reset() {
	var v DefinitionsJsonschemaDraft4PropertiesTitle
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsJsonschemaDraft4PropertiesTitle) SetTo(v DefinitionsJsonschemaDraft4PropertiesTitle) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesTitle) Get() (v DefinitionsJsonschemaDraft4PropertiesTitle, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsJsonschemaDraft4PropertiesTitle) Or(d DefinitionsJsonschemaDraft4PropertiesTitle) DefinitionsJsonschemaDraft4PropertiesTitle {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsJsonschemaDraft4PropertiesUniqueItems returns new OptDefinitionsJsonschemaDraft4PropertiesUniqueItems with value set to v.
func NewOptDefinitionsJsonschemaDraft4PropertiesUniqueItems(v DefinitionsJsonschemaDraft4PropertiesUniqueItems) OptDefinitionsJsonschemaDraft4PropertiesUniqueItems {
	return OptDefinitionsJsonschemaDraft4PropertiesUniqueItems{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsJsonschemaDraft4PropertiesUniqueItems is optional DefinitionsJsonschemaDraft4PropertiesUniqueItems.
type OptDefinitionsJsonschemaDraft4PropertiesUniqueItems struct {
	Value DefinitionsJsonschemaDraft4PropertiesUniqueItems
	Set   bool
}

// IsSet returns true if OptDefinitionsJsonschemaDraft4PropertiesUniqueItems was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesUniqueItems) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsJsonschemaDraft4PropertiesUniqueItems) Reset() {
	var v DefinitionsJsonschemaDraft4PropertiesUniqueItems
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsJsonschemaDraft4PropertiesUniqueItems) SetTo(v DefinitionsJsonschemaDraft4PropertiesUniqueItems) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsJsonschemaDraft4PropertiesUniqueItems) Get() (v DefinitionsJsonschemaDraft4PropertiesUniqueItems, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsJsonschemaDraft4PropertiesUniqueItems) Or(d DefinitionsJsonschemaDraft4PropertiesUniqueItems) DefinitionsJsonschemaDraft4PropertiesUniqueItems {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsLicense returns new OptDefinitionsLicense with value set to v.
func NewOptDefinitionsLicense(v DefinitionsLicense) OptDefinitionsLicense {
	return OptDefinitionsLicense{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsLicense is optional DefinitionsLicense.
type OptDefinitionsLicense struct {
	Value DefinitionsLicense
	Set   bool
}

// IsSet returns true if OptDefinitionsLicense was set.
func (o OptDefinitionsLicense) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsLicense) Reset() {
	var v DefinitionsLicense
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsLicense) SetTo(v DefinitionsLicense) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsLicense) Get() (v DefinitionsLicense, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsLicense) Or(d DefinitionsLicense) DefinitionsLicense {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsLinksOrReferences returns new OptDefinitionsLinksOrReferences with value set to v.
func NewOptDefinitionsLinksOrReferences(v DefinitionsLinksOrReferences) OptDefinitionsLinksOrReferences {
	return OptDefinitionsLinksOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsLinksOrReferences is optional DefinitionsLinksOrReferences.
type OptDefinitionsLinksOrReferences struct {
	Value DefinitionsLinksOrReferences
	Set   bool
}

// IsSet returns true if OptDefinitionsLinksOrReferences was set.
func (o OptDefinitionsLinksOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsLinksOrReferences) Reset() {
	var v DefinitionsLinksOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsLinksOrReferences) SetTo(v DefinitionsLinksOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsLinksOrReferences) Get() (v DefinitionsLinksOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsLinksOrReferences) Or(d DefinitionsLinksOrReferences) DefinitionsLinksOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsMediaTypes returns new OptDefinitionsMediaTypes with value set to v.
func NewOptDefinitionsMediaTypes(v DefinitionsMediaTypes) OptDefinitionsMediaTypes {
	return OptDefinitionsMediaTypes{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsMediaTypes is optional DefinitionsMediaTypes.
type OptDefinitionsMediaTypes struct {
	Value DefinitionsMediaTypes
	Set   bool
}

// IsSet returns true if OptDefinitionsMediaTypes was set.
func (o OptDefinitionsMediaTypes) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsMediaTypes) Reset() {
	var v DefinitionsMediaTypes
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsMediaTypes) SetTo(v DefinitionsMediaTypes) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsMediaTypes) Get() (v DefinitionsMediaTypes, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsMediaTypes) Or(d DefinitionsMediaTypes) DefinitionsMediaTypes {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsOauthFlow returns new OptDefinitionsOauthFlow with value set to v.
func NewOptDefinitionsOauthFlow(v DefinitionsOauthFlow) OptDefinitionsOauthFlow {
	return OptDefinitionsOauthFlow{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsOauthFlow is optional DefinitionsOauthFlow.
type OptDefinitionsOauthFlow struct {
	Value DefinitionsOauthFlow
	Set   bool
}

// IsSet returns true if OptDefinitionsOauthFlow was set.
func (o OptDefinitionsOauthFlow) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsOauthFlow) Reset() {
	var v DefinitionsOauthFlow
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsOauthFlow) SetTo(v DefinitionsOauthFlow) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsOauthFlow) Get() (v DefinitionsOauthFlow, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsOauthFlow) Or(d DefinitionsOauthFlow) DefinitionsOauthFlow {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsOauthFlows returns new OptDefinitionsOauthFlows with value set to v.
func NewOptDefinitionsOauthFlows(v DefinitionsOauthFlows) OptDefinitionsOauthFlows {
	return OptDefinitionsOauthFlows{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsOauthFlows is optional DefinitionsOauthFlows.
type OptDefinitionsOauthFlows struct {
	Value DefinitionsOauthFlows
	Set   bool
}

// IsSet returns true if OptDefinitionsOauthFlows was set.
func (o OptDefinitionsOauthFlows) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsOauthFlows) Reset() {
	var v DefinitionsOauthFlows
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsOauthFlows) SetTo(v DefinitionsOauthFlows) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsOauthFlows) Get() (v DefinitionsOauthFlows, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsOauthFlows) Or(d DefinitionsOauthFlows) DefinitionsOauthFlows {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsOperation returns new OptDefinitionsOperation with value set to v.
func NewOptDefinitionsOperation(v DefinitionsOperation) OptDefinitionsOperation {
	return OptDefinitionsOperation{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsOperation is optional DefinitionsOperation.
type OptDefinitionsOperation struct {
	Value DefinitionsOperation
	Set   bool
}

// IsSet returns true if OptDefinitionsOperation was set.
func (o OptDefinitionsOperation) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsOperation) Reset() {
	var v DefinitionsOperation
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsOperation) SetTo(v DefinitionsOperation) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsOperation) Get() (v DefinitionsOperation, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsOperation) Or(d DefinitionsOperation) DefinitionsOperation {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsParameterStyle returns new OptDefinitionsParameterStyle with value set to v.
func NewOptDefinitionsParameterStyle(v DefinitionsParameterStyle) OptDefinitionsParameterStyle {
	return OptDefinitionsParameterStyle{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsParameterStyle is optional DefinitionsParameterStyle.
type OptDefinitionsParameterStyle struct {
	Value DefinitionsParameterStyle
	Set   bool
}

// IsSet returns true if OptDefinitionsParameterStyle was set.
func (o OptDefinitionsParameterStyle) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsParameterStyle) Reset() {
	var v DefinitionsParameterStyle
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsParameterStyle) SetTo(v DefinitionsParameterStyle) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsParameterStyle) Get() (v DefinitionsParameterStyle, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsParameterStyle) Or(d DefinitionsParameterStyle) DefinitionsParameterStyle {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsParametersOrReferences returns new OptDefinitionsParametersOrReferences with value set to v.
func NewOptDefinitionsParametersOrReferences(v DefinitionsParametersOrReferences) OptDefinitionsParametersOrReferences {
	return OptDefinitionsParametersOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsParametersOrReferences is optional DefinitionsParametersOrReferences.
type OptDefinitionsParametersOrReferences struct {
	Value DefinitionsParametersOrReferences
	Set   bool
}

// IsSet returns true if OptDefinitionsParametersOrReferences was set.
func (o OptDefinitionsParametersOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsParametersOrReferences) Reset() {
	var v DefinitionsParametersOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsParametersOrReferences) SetTo(v DefinitionsParametersOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsParametersOrReferences) Get() (v DefinitionsParametersOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsParametersOrReferences) Or(d DefinitionsParametersOrReferences) DefinitionsParametersOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsPositiveInteger returns new OptDefinitionsPositiveInteger with value set to v.
func NewOptDefinitionsPositiveInteger(v DefinitionsPositiveInteger) OptDefinitionsPositiveInteger {
	return OptDefinitionsPositiveInteger{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsPositiveInteger is optional DefinitionsPositiveInteger.
type OptDefinitionsPositiveInteger struct {
	Value DefinitionsPositiveInteger
	Set   bool
}

// IsSet returns true if OptDefinitionsPositiveInteger was set.
func (o OptDefinitionsPositiveInteger) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsPositiveInteger) Reset() {
	var v DefinitionsPositiveInteger
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsPositiveInteger) SetTo(v DefinitionsPositiveInteger) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsPositiveInteger) Get() (v DefinitionsPositiveInteger, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsPositiveInteger) Or(d DefinitionsPositiveInteger) DefinitionsPositiveInteger {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsRequestBodiesOrReferences returns new OptDefinitionsRequestBodiesOrReferences with value set to v.
func NewOptDefinitionsRequestBodiesOrReferences(v DefinitionsRequestBodiesOrReferences) OptDefinitionsRequestBodiesOrReferences {
	return OptDefinitionsRequestBodiesOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsRequestBodiesOrReferences is optional DefinitionsRequestBodiesOrReferences.
type OptDefinitionsRequestBodiesOrReferences struct {
	Value DefinitionsRequestBodiesOrReferences
	Set   bool
}

// IsSet returns true if OptDefinitionsRequestBodiesOrReferences was set.
func (o OptDefinitionsRequestBodiesOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsRequestBodiesOrReferences) Reset() {
	var v DefinitionsRequestBodiesOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsRequestBodiesOrReferences) SetTo(v DefinitionsRequestBodiesOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsRequestBodiesOrReferences) Get() (v DefinitionsRequestBodiesOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsRequestBodiesOrReferences) Or(d DefinitionsRequestBodiesOrReferences) DefinitionsRequestBodiesOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsRequestBodyOrReference returns new OptDefinitionsRequestBodyOrReference with value set to v.
func NewOptDefinitionsRequestBodyOrReference(v DefinitionsRequestBodyOrReference) OptDefinitionsRequestBodyOrReference {
	return OptDefinitionsRequestBodyOrReference{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsRequestBodyOrReference is optional DefinitionsRequestBodyOrReference.
type OptDefinitionsRequestBodyOrReference struct {
	Value DefinitionsRequestBodyOrReference
	Set   bool
}

// IsSet returns true if OptDefinitionsRequestBodyOrReference was set.
func (o OptDefinitionsRequestBodyOrReference) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsRequestBodyOrReference) Reset() {
	var v DefinitionsRequestBodyOrReference
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsRequestBodyOrReference) SetTo(v DefinitionsRequestBodyOrReference) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsRequestBodyOrReference) Get() (v DefinitionsRequestBodyOrReference, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsRequestBodyOrReference) Or(d DefinitionsRequestBodyOrReference) DefinitionsRequestBodyOrReference {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsResponseOrReference returns new OptDefinitionsResponseOrReference with value set to v.
func NewOptDefinitionsResponseOrReference(v DefinitionsResponseOrReference) OptDefinitionsResponseOrReference {
	return OptDefinitionsResponseOrReference{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsResponseOrReference is optional DefinitionsResponseOrReference.
type OptDefinitionsResponseOrReference struct {
	Value DefinitionsResponseOrReference
	Set   bool
}

// IsSet returns true if OptDefinitionsResponseOrReference was set.
func (o OptDefinitionsResponseOrReference) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsResponseOrReference) Reset() {
	var v DefinitionsResponseOrReference
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsResponseOrReference) SetTo(v DefinitionsResponseOrReference) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsResponseOrReference) Get() (v DefinitionsResponseOrReference, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsResponseOrReference) Or(d DefinitionsResponseOrReference) DefinitionsResponseOrReference {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsResponsesOrReferences returns new OptDefinitionsResponsesOrReferences with value set to v.
func NewOptDefinitionsResponsesOrReferences(v DefinitionsResponsesOrReferences) OptDefinitionsResponsesOrReferences {
	return OptDefinitionsResponsesOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsResponsesOrReferences is optional DefinitionsResponsesOrReferences.
type OptDefinitionsResponsesOrReferences struct {
	Value DefinitionsResponsesOrReferences
	Set   bool
}

// IsSet returns true if OptDefinitionsResponsesOrReferences was set.
func (o OptDefinitionsResponsesOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsResponsesOrReferences) Reset() {
	var v DefinitionsResponsesOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsResponsesOrReferences) SetTo(v DefinitionsResponsesOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsResponsesOrReferences) Get() (v DefinitionsResponsesOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsResponsesOrReferences) Or(d DefinitionsResponsesOrReferences) DefinitionsResponsesOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsSchemaOrReference returns new OptDefinitionsSchemaOrReference with value set to v.
func NewOptDefinitionsSchemaOrReference(v DefinitionsSchemaOrReference) OptDefinitionsSchemaOrReference {
	return OptDefinitionsSchemaOrReference{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsSchemaOrReference is optional DefinitionsSchemaOrReference.
type OptDefinitionsSchemaOrReference struct {
	Value DefinitionsSchemaOrReference
	Set   bool
}

// IsSet returns true if OptDefinitionsSchemaOrReference was set.
func (o OptDefinitionsSchemaOrReference) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsSchemaOrReference) Reset() {
	var v DefinitionsSchemaOrReference
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsSchemaOrReference) SetTo(v DefinitionsSchemaOrReference) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsSchemaOrReference) Get() (v DefinitionsSchemaOrReference, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsSchemaOrReference) Or(d DefinitionsSchemaOrReference) DefinitionsSchemaOrReference {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsSchemaProperties returns new OptDefinitionsSchemaProperties with value set to v.
func NewOptDefinitionsSchemaProperties(v DefinitionsSchemaProperties) OptDefinitionsSchemaProperties {
	return OptDefinitionsSchemaProperties{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsSchemaProperties is optional DefinitionsSchemaProperties.
type OptDefinitionsSchemaProperties struct {
	Value DefinitionsSchemaProperties
	Set   bool
}

// IsSet returns true if OptDefinitionsSchemaProperties was set.
func (o OptDefinitionsSchemaProperties) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsSchemaProperties) Reset() {
	var v DefinitionsSchemaProperties
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsSchemaProperties) SetTo(v DefinitionsSchemaProperties) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsSchemaProperties) Get() (v DefinitionsSchemaProperties, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsSchemaProperties) Or(d DefinitionsSchemaProperties) DefinitionsSchemaProperties {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsSchemaType returns new OptDefinitionsSchemaType with value set to v.
func NewOptDefinitionsSchemaType(v DefinitionsSchemaType) OptDefinitionsSchemaType {
	return OptDefinitionsSchemaType{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsSchemaType is optional DefinitionsSchemaType.
type OptDefinitionsSchemaType struct {
	Value DefinitionsSchemaType
	Set   bool
}

// IsSet returns true if OptDefinitionsSchemaType was set.
func (o OptDefinitionsSchemaType) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsSchemaType) Reset() {
	var v DefinitionsSchemaType
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsSchemaType) SetTo(v DefinitionsSchemaType) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsSchemaType) Get() (v DefinitionsSchemaType, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsSchemaType) Or(d DefinitionsSchemaType) DefinitionsSchemaType {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsSchemasOrReferences returns new OptDefinitionsSchemasOrReferences with value set to v.
func NewOptDefinitionsSchemasOrReferences(v DefinitionsSchemasOrReferences) OptDefinitionsSchemasOrReferences {
	return OptDefinitionsSchemasOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsSchemasOrReferences is optional DefinitionsSchemasOrReferences.
type OptDefinitionsSchemasOrReferences struct {
	Value DefinitionsSchemasOrReferences
	Set   bool
}

// IsSet returns true if OptDefinitionsSchemasOrReferences was set.
func (o OptDefinitionsSchemasOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsSchemasOrReferences) Reset() {
	var v DefinitionsSchemasOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsSchemasOrReferences) SetTo(v DefinitionsSchemasOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsSchemasOrReferences) Get() (v DefinitionsSchemasOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsSchemasOrReferences) Or(d DefinitionsSchemasOrReferences) DefinitionsSchemasOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsSecuritySchemesOrReferences returns new OptDefinitionsSecuritySchemesOrReferences with value set to v.
func NewOptDefinitionsSecuritySchemesOrReferences(v DefinitionsSecuritySchemesOrReferences) OptDefinitionsSecuritySchemesOrReferences {
	return OptDefinitionsSecuritySchemesOrReferences{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsSecuritySchemesOrReferences is optional DefinitionsSecuritySchemesOrReferences.
type OptDefinitionsSecuritySchemesOrReferences struct {
	Value DefinitionsSecuritySchemesOrReferences
	Set   bool
}

// IsSet returns true if OptDefinitionsSecuritySchemesOrReferences was set.
func (o OptDefinitionsSecuritySchemesOrReferences) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsSecuritySchemesOrReferences) Reset() {
	var v DefinitionsSecuritySchemesOrReferences
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsSecuritySchemesOrReferences) SetTo(v DefinitionsSecuritySchemesOrReferences) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsSecuritySchemesOrReferences) Get() (v DefinitionsSecuritySchemesOrReferences, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsSecuritySchemesOrReferences) Or(d DefinitionsSecuritySchemesOrReferences) DefinitionsSecuritySchemesOrReferences {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsServer returns new OptDefinitionsServer with value set to v.
func NewOptDefinitionsServer(v DefinitionsServer) OptDefinitionsServer {
	return OptDefinitionsServer{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsServer is optional DefinitionsServer.
type OptDefinitionsServer struct {
	Value DefinitionsServer
	Set   bool
}

// IsSet returns true if OptDefinitionsServer was set.
func (o OptDefinitionsServer) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsServer) Reset() {
	var v DefinitionsServer
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsServer) SetTo(v DefinitionsServer) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsServer) Get() (v DefinitionsServer, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsServer) Or(d DefinitionsServer) DefinitionsServer {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsServerVariables returns new OptDefinitionsServerVariables with value set to v.
func NewOptDefinitionsServerVariables(v DefinitionsServerVariables) OptDefinitionsServerVariables {
	return OptDefinitionsServerVariables{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsServerVariables is optional DefinitionsServerVariables.
type OptDefinitionsServerVariables struct {
	Value DefinitionsServerVariables
	Set   bool
}

// IsSet returns true if OptDefinitionsServerVariables was set.
func (o OptDefinitionsServerVariables) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsServerVariables) Reset() {
	var v DefinitionsServerVariables
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsServerVariables) SetTo(v DefinitionsServerVariables) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsServerVariables) Get() (v DefinitionsServerVariables, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsServerVariables) Or(d DefinitionsServerVariables) DefinitionsServerVariables {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsStrings returns new OptDefinitionsStrings with value set to v.
func NewOptDefinitionsStrings(v DefinitionsStrings) OptDefinitionsStrings {
	return OptDefinitionsStrings{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsStrings is optional DefinitionsStrings.
type OptDefinitionsStrings struct {
	Value DefinitionsStrings
	Set   bool
}

// IsSet returns true if OptDefinitionsStrings was set.
func (o OptDefinitionsStrings) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsStrings) Reset() {
	var v DefinitionsStrings
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsStrings) SetTo(v DefinitionsStrings) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsStrings) Get() (v DefinitionsStrings, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsStrings) Or(d DefinitionsStrings) DefinitionsStrings {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptDefinitionsXML returns new OptDefinitionsXML with value set to v.
func NewOptDefinitionsXML(v DefinitionsXML) OptDefinitionsXML {
	return OptDefinitionsXML{
		Value: v,
		Set:   true,
	}
}

// OptDefinitionsXML is optional DefinitionsXML.
type OptDefinitionsXML struct {
	Value DefinitionsXML
	Set   bool
}

// IsSet returns true if OptDefinitionsXML was set.
func (o OptDefinitionsXML) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptDefinitionsXML) Reset() {
	var v DefinitionsXML
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptDefinitionsXML) SetTo(v DefinitionsXML) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptDefinitionsXML) Get() (v DefinitionsXML, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptDefinitionsXML) Or(d DefinitionsXML) DefinitionsXML {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// NewOptString returns new OptString with value set to v.
func NewOptString(v string) OptString {
	return OptString{
		Value: v,
		Set:   true,
	}
}

// OptString is optional string.
type OptString struct {
	Value string
	Set   bool
}

// IsSet returns true if OptString was set.
func (o OptString) IsSet() bool { return o.Set }

// Reset unsets value.
func (o *OptString) Reset() {
	var v string
	o.Value = v
	o.Set = false
}

// SetTo sets value to v.
func (o *OptString) SetTo(v string) {
	o.Set = true
	o.Value = v
}

// Get returns value and boolean that denotes whether value was set.
func (o OptString) Get() (v string, ok bool) {
	if !o.Set {
		return v, false
	}
	return o.Value, true
}

// Or returns value if set, or given parameter if does not.
func (o OptString) Or(d string) string {
	if v, ok := o.Get(); ok {
		return v
	}
	return d
}

// This is the root document object of the OpenAPI document.
type Spec struct {
	Openapi         string                           "json:\"openapi\""
	Info            DefinitionsInfo                  "json:\"info\""
	Servers         []DefinitionsServer              "json:\"servers\""
	Paths           DefinitionsPaths                 "json:\"paths\""
	Components      OptDefinitionsComponents         "json:\"components\""
	Security        []DefinitionsSecurityRequirement "json:\"security\""
	Tags            []DefinitionsTag                 "json:\"tags\""
	ExternalDocs    OptDefinitionsExternalDocs       "json:\"externalDocs\""
	AdditionalProps SpecAdditional
	Pattern0Props   SpecPattern0
}

type SpecAdditional map[string]jx.Raw

func (s *SpecAdditional) init() SpecAdditional {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

type SpecPattern0 map[string]jx.Raw

func (s *SpecPattern0) init() SpecPattern0 {
	m := *s
	if m == nil {
		m = map[string]jx.Raw{}
		*s = m
	}
	return m
}

// setDefaults set default value of fields.
func (s *DefinitionsSchema) setDefaults() {
	{
		val := DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum(false)

		s.ExclusiveMaximum.SetTo(val)
	}
	{
		val := DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum(false)

		s.ExclusiveMinimum.SetTo(val)
	}
	{
		val := DefinitionsJsonschemaDraft4PropertiesUniqueItems(false)

		s.UniqueItems.SetTo(val)
	}
}

// Encode implements json.Marshaler.
func (s DefinitionsAnysOrExpressions) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsAnysOrExpressions) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsAnysOrExpressions from json.
func (s *DefinitionsAnysOrExpressions) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsAnysOrExpressions to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsAnysOrExpressions")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsAnysOrExpressions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsAnysOrExpressions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsCallback) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsCallback) encodeFields(e *jx.Encoder) {
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		elem.Encode(e)
	}
	for k, elem := range s.Pattern1Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsCallback = [0]string{}

// Decode decodes DefinitionsCallback from json.
func (s *DefinitionsCallback) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsCallback to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]DefinitionsPathItem{}
	s.Pattern1Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var handled bool
			if pattern := regexMap["^"]; pattern.Match(k) {
				handled = true
				var elem DefinitionsPathItem
				if err := func() error {
					if err := elem.Decode(d); err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern1Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsCallback")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsCallback) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsCallback) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsCallbackAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsCallbackAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsCallbackAdditional from json.
func (s *DefinitionsCallbackAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsCallbackAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsCallbackAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsCallbackAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsCallbackAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsCallbackOrReference as json.
func (s DefinitionsCallbackOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case DefinitionsCallbackDefinitionsCallbackOrReference:
		s.DefinitionsCallback.Encode(e)
	case DefinitionsReferenceDefinitionsCallbackOrReference:
		s.DefinitionsReference.Encode(e)
	}
}

// Decode decodes DefinitionsCallbackOrReference from json.
func (s *DefinitionsCallbackOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsCallbackOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "$ref":
				found = true
				s.Type = DefinitionsReferenceDefinitionsCallbackOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		s.Type = DefinitionsCallbackDefinitionsCallbackOrReference
	}
	switch s.Type {
	case DefinitionsCallbackDefinitionsCallbackOrReference:
		if err := s.DefinitionsCallback.Decode(d); err != nil {
			return err
		}
	case DefinitionsReferenceDefinitionsCallbackOrReference:
		if err := s.DefinitionsReference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsCallbackOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsCallbackOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsCallbackPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsCallbackPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsCallbackPattern0 from json.
func (s *DefinitionsCallbackPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsCallbackPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem DefinitionsPathItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsCallbackPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsCallbackPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsCallbackPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsCallbackPattern1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsCallbackPattern1) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsCallbackPattern1 from json.
func (s *DefinitionsCallbackPattern1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsCallbackPattern1 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsCallbackPattern1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsCallbackPattern1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsCallbackPattern1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsCallbacksOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsCallbacksOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsCallbacksOrReferences from json.
func (s *DefinitionsCallbacksOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsCallbacksOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DefinitionsCallbackOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsCallbacksOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsCallbacksOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsCallbacksOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsComponents) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsComponents) encodeFields(e *jx.Encoder) {
	{
		if s.Schemas.Set {
			e.FieldStart("schemas")
			s.Schemas.Encode(e)
		}
	}
	{
		if s.Responses.Set {
			e.FieldStart("responses")
			s.Responses.Encode(e)
		}
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
	{
		if s.Examples.Set {
			e.FieldStart("examples")
			s.Examples.Encode(e)
		}
	}
	{
		if s.RequestBodies.Set {
			e.FieldStart("requestBodies")
			s.RequestBodies.Encode(e)
		}
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		if s.SecuritySchemes.Set {
			e.FieldStart("securitySchemes")
			s.SecuritySchemes.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	{
		if s.Callbacks.Set {
			e.FieldStart("callbacks")
			s.Callbacks.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsComponents = [9]string{
	0: "schemas",
	1: "responses",
	2: "parameters",
	3: "examples",
	4: "requestBodies",
	5: "headers",
	6: "securitySchemes",
	7: "links",
	8: "callbacks",
}

// Decode decodes DefinitionsComponents from json.
func (s *DefinitionsComponents) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsComponents to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schemas":
			if err := func() error {
				s.Schemas.Reset()
				if err := s.Schemas.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schemas\"")
			}
		case "responses":
			if err := func() error {
				s.Responses.Reset()
				if err := s.Responses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responses\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "examples":
			if err := func() error {
				s.Examples.Reset()
				if err := s.Examples.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"examples\"")
			}
		case "requestBodies":
			if err := func() error {
				s.RequestBodies.Reset()
				if err := s.RequestBodies.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestBodies\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "securitySchemes":
			if err := func() error {
				s.SecuritySchemes.Reset()
				if err := s.SecuritySchemes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"securitySchemes\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		case "callbacks":
			if err := func() error {
				s.Callbacks.Reset()
				if err := s.Callbacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"callbacks\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsComponents")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsComponents) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsComponents) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsComponentsAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsComponentsAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsComponentsAdditional from json.
func (s *DefinitionsComponentsAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsComponentsAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsComponentsAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsComponentsAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsComponentsAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsComponentsPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsComponentsPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsComponentsPattern0 from json.
func (s *DefinitionsComponentsPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsComponentsPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsComponentsPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsComponentsPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsComponentsPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsContact) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsContact) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	{
		if s.Email.Set {
			e.FieldStart("email")
			s.Email.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsContact = [3]string{
	0: "name",
	1: "url",
	2: "email",
}

// Decode decodes DefinitionsContact from json.
func (s *DefinitionsContact) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsContact to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "email":
			if err := func() error {
				s.Email.Reset()
				if err := s.Email.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"email\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsContact")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsContact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsContact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsContactAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsContactAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsContactAdditional from json.
func (s *DefinitionsContactAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsContactAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsContactAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsContactAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsContactAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsContactPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsContactPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsContactPattern0 from json.
func (s *DefinitionsContactPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsContactPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsContactPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsContactPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsContactPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsDiscriminator) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsDiscriminator) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("propertyName")
		e.Str(s.PropertyName)
	}
	{
		if s.Mapping.Set {
			e.FieldStart("mapping")
			s.Mapping.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsDiscriminator = [2]string{
	0: "propertyName",
	1: "mapping",
}

// Decode decodes DefinitionsDiscriminator from json.
func (s *DefinitionsDiscriminator) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsDiscriminator to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "propertyName":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.PropertyName = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"propertyName\"")
			}
		case "mapping":
			if err := func() error {
				s.Mapping.Reset()
				if err := s.Mapping.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"mapping\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsDiscriminator")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDefinitionsDiscriminator) {
					name = jsonFieldsNameOfDefinitionsDiscriminator[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsDiscriminator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsDiscriminator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsDiscriminatorAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsDiscriminatorAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsDiscriminatorAdditional from json.
func (s *DefinitionsDiscriminatorAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsDiscriminatorAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsDiscriminatorAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsDiscriminatorAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsDiscriminatorAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsEncoding) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsEncoding) encodeFields(e *jx.Encoder) {
	{
		if s.ContentType.Set {
			e.FieldStart("contentType")
			s.ContentType.Encode(e)
		}
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		if s.Style.Set {
			e.FieldStart("style")
			s.Style.Encode(e)
		}
	}
	{
		if s.Explode.Set {
			e.FieldStart("explode")
			s.Explode.Encode(e)
		}
	}
	{
		if s.AllowReserved.Set {
			e.FieldStart("allowReserved")
			s.AllowReserved.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsEncoding = [5]string{
	0: "contentType",
	1: "headers",
	2: "style",
	3: "explode",
	4: "allowReserved",
}

// Decode decodes DefinitionsEncoding from json.
func (s *DefinitionsEncoding) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsEncoding to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "contentType":
			if err := func() error {
				s.ContentType.Reset()
				if err := s.ContentType.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contentType\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "style":
			if err := func() error {
				s.Style.Reset()
				if err := s.Style.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"style\"")
			}
		case "explode":
			if err := func() error {
				s.Explode.Reset()
				if err := s.Explode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explode\"")
			}
		case "allowReserved":
			if err := func() error {
				s.AllowReserved.Reset()
				if err := s.AllowReserved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowReserved\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsEncoding")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsEncoding) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsEncoding) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsEncodingAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsEncodingAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsEncodingAdditional from json.
func (s *DefinitionsEncodingAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsEncodingAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsEncodingAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsEncodingAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsEncodingAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsEncodingPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsEncodingPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsEncodingPattern0 from json.
func (s *DefinitionsEncodingPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsEncodingPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsEncodingPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsEncodingPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsEncodingPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsEncodings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsEncodings) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsEncodings from json.
func (s *DefinitionsEncodings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsEncodings to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DefinitionsEncoding
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsEncodings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsEncodings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsEncodings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsExample) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsExample) encodeFields(e *jx.Encoder) {
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{

		if len(s.Value) != 0 {
			e.FieldStart("value")
			e.Raw(s.Value)
		}
	}
	{
		if s.ExternalValue.Set {
			e.FieldStart("externalValue")
			s.ExternalValue.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsExample = [4]string{
	0: "summary",
	1: "description",
	2: "value",
	3: "externalValue",
}

// Decode decodes DefinitionsExample from json.
func (s *DefinitionsExample) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsExample to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "value":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Value = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"value\"")
			}
		case "externalValue":
			if err := func() error {
				s.ExternalValue.Reset()
				if err := s.ExternalValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalValue\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsExample")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsExample) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsExample) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsExampleAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsExampleAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsExampleAdditional from json.
func (s *DefinitionsExampleAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsExampleAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsExampleAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsExampleAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsExampleAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsExampleOrReference as json.
func (s DefinitionsExampleOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case DefinitionsExampleDefinitionsExampleOrReference:
		s.DefinitionsExample.Encode(e)
	case DefinitionsReferenceDefinitionsExampleOrReference:
		s.DefinitionsReference.Encode(e)
	}
}

// Decode decodes DefinitionsExampleOrReference from json.
func (s *DefinitionsExampleOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsExampleOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "summary":
				found = true
				s.Type = DefinitionsExampleDefinitionsExampleOrReference
			case "description":
				found = true
				s.Type = DefinitionsExampleDefinitionsExampleOrReference
			case "value":
				found = true
				s.Type = DefinitionsExampleDefinitionsExampleOrReference
			case "externalValue":
				found = true
				s.Type = DefinitionsExampleDefinitionsExampleOrReference
			case "$ref":
				found = true
				s.Type = DefinitionsReferenceDefinitionsExampleOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DefinitionsExampleDefinitionsExampleOrReference:
		if err := s.DefinitionsExample.Decode(d); err != nil {
			return err
		}
	case DefinitionsReferenceDefinitionsExampleOrReference:
		if err := s.DefinitionsReference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsExampleOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsExampleOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsExamplePattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsExamplePattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsExamplePattern0 from json.
func (s *DefinitionsExamplePattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsExamplePattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsExamplePattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsExamplePattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsExamplePattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsExamplesOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsExamplesOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsExamplesOrReferences from json.
func (s *DefinitionsExamplesOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsExamplesOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DefinitionsExampleOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsExamplesOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsExamplesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsExamplesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsExternalDocs) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsExternalDocs) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{

		e.FieldStart("url")
		e.Str(s.URL)
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsExternalDocs = [2]string{
	0: "description",
	1: "url",
}

// Decode decodes DefinitionsExternalDocs from json.
func (s *DefinitionsExternalDocs) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsExternalDocs to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "url":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsExternalDocs")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDefinitionsExternalDocs) {
					name = jsonFieldsNameOfDefinitionsExternalDocs[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsExternalDocs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsExternalDocs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsExternalDocsAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsExternalDocsAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsExternalDocsAdditional from json.
func (s *DefinitionsExternalDocsAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsExternalDocsAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsExternalDocsAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsExternalDocsAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsExternalDocsAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsExternalDocsPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsExternalDocsPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsExternalDocsPattern0 from json.
func (s *DefinitionsExternalDocsPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsExternalDocsPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsExternalDocsPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsExternalDocsPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsExternalDocsPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsHeader) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsHeader) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Required.Set {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
	{
		if s.Deprecated.Set {
			e.FieldStart("deprecated")
			s.Deprecated.Encode(e)
		}
	}
	{
		if s.AllowEmptyValue.Set {
			e.FieldStart("allowEmptyValue")
			s.AllowEmptyValue.Encode(e)
		}
	}
	{
		if s.Style.Set {
			e.FieldStart("style")
			s.Style.Encode(e)
		}
	}
	{
		if s.Explode.Set {
			e.FieldStart("explode")
			s.Explode.Encode(e)
		}
	}
	{
		if s.AllowReserved.Set {
			e.FieldStart("allowReserved")
			s.AllowReserved.Encode(e)
		}
	}
	{
		if s.Schema.Set {
			e.FieldStart("schema")
			s.Schema.Encode(e)
		}
	}
	{

		if len(s.Example) != 0 {
			e.FieldStart("example")
			e.Raw(s.Example)
		}
	}
	{
		if s.Examples.Set {
			e.FieldStart("examples")
			s.Examples.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsHeader = [11]string{
	0:  "description",
	1:  "required",
	2:  "deprecated",
	3:  "allowEmptyValue",
	4:  "style",
	5:  "explode",
	6:  "allowReserved",
	7:  "schema",
	8:  "example",
	9:  "examples",
	10: "content",
}

// Decode decodes DefinitionsHeader from json.
func (s *DefinitionsHeader) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsHeader to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		case "deprecated":
			if err := func() error {
				s.Deprecated.Reset()
				if err := s.Deprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecated\"")
			}
		case "allowEmptyValue":
			if err := func() error {
				s.AllowEmptyValue.Reset()
				if err := s.AllowEmptyValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowEmptyValue\"")
			}
		case "style":
			if err := func() error {
				s.Style.Reset()
				if err := s.Style.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"style\"")
			}
		case "explode":
			if err := func() error {
				s.Explode.Reset()
				if err := s.Explode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explode\"")
			}
		case "allowReserved":
			if err := func() error {
				s.AllowReserved.Reset()
				if err := s.AllowReserved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowReserved\"")
			}
		case "schema":
			if err := func() error {
				s.Schema.Reset()
				if err := s.Schema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		case "example":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Example = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"example\"")
			}
		case "examples":
			if err := func() error {
				s.Examples.Reset()
				if err := s.Examples.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"examples\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsHeader")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsHeader) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsHeader) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsHeaderAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsHeaderAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsHeaderAdditional from json.
func (s *DefinitionsHeaderAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsHeaderAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsHeaderAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsHeaderAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsHeaderAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsHeaderOrReference as json.
func (s DefinitionsHeaderOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case DefinitionsHeaderDefinitionsHeaderOrReference:
		s.DefinitionsHeader.Encode(e)
	case DefinitionsReferenceDefinitionsHeaderOrReference:
		s.DefinitionsReference.Encode(e)
	}
}

// Decode decodes DefinitionsHeaderOrReference from json.
func (s *DefinitionsHeaderOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsHeaderOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "description":
				found = true
				s.Type = DefinitionsHeaderDefinitionsHeaderOrReference
			case "required":
				found = true
				s.Type = DefinitionsHeaderDefinitionsHeaderOrReference
			case "deprecated":
				found = true
				s.Type = DefinitionsHeaderDefinitionsHeaderOrReference
			case "allowEmptyValue":
				found = true
				s.Type = DefinitionsHeaderDefinitionsHeaderOrReference
			case "style":
				found = true
				s.Type = DefinitionsHeaderDefinitionsHeaderOrReference
			case "explode":
				found = true
				s.Type = DefinitionsHeaderDefinitionsHeaderOrReference
			case "allowReserved":
				found = true
				s.Type = DefinitionsHeaderDefinitionsHeaderOrReference
			case "schema":
				found = true
				s.Type = DefinitionsHeaderDefinitionsHeaderOrReference
			case "example":
				found = true
				s.Type = DefinitionsHeaderDefinitionsHeaderOrReference
			case "examples":
				found = true
				s.Type = DefinitionsHeaderDefinitionsHeaderOrReference
			case "content":
				found = true
				s.Type = DefinitionsHeaderDefinitionsHeaderOrReference
			case "$ref":
				found = true
				s.Type = DefinitionsReferenceDefinitionsHeaderOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DefinitionsHeaderDefinitionsHeaderOrReference:
		if err := s.DefinitionsHeader.Decode(d); err != nil {
			return err
		}
	case DefinitionsReferenceDefinitionsHeaderOrReference:
		if err := s.DefinitionsReference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsHeaderOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsHeaderOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsHeaderPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsHeaderPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsHeaderPattern0 from json.
func (s *DefinitionsHeaderPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsHeaderPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsHeaderPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsHeaderPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsHeaderPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsHeadersOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsHeadersOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsHeadersOrReferences from json.
func (s *DefinitionsHeadersOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsHeadersOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DefinitionsHeaderOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsHeadersOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsHeadersOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsHeadersOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsInfo) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsInfo) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("title")
		e.Str(s.Title)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.TermsOfService.Set {
			e.FieldStart("termsOfService")
			s.TermsOfService.Encode(e)
		}
	}
	{
		if s.Contact.Set {
			e.FieldStart("contact")
			s.Contact.Encode(e)
		}
	}
	{
		if s.License.Set {
			e.FieldStart("license")
			s.License.Encode(e)
		}
	}
	{

		e.FieldStart("version")
		e.Str(s.Version)
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsInfo = [6]string{
	0: "title",
	1: "description",
	2: "termsOfService",
	3: "contact",
	4: "license",
	5: "version",
}

// Decode decodes DefinitionsInfo from json.
func (s *DefinitionsInfo) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsInfo to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "title":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Title = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "termsOfService":
			if err := func() error {
				s.TermsOfService.Reset()
				if err := s.TermsOfService.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"termsOfService\"")
			}
		case "contact":
			if err := func() error {
				s.Contact.Reset()
				if err := s.Contact.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"contact\"")
			}
		case "license":
			if err := func() error {
				s.License.Reset()
				if err := s.License.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"license\"")
			}
		case "version":
			requiredBitSet[0] |= 1 << 5
			if err := func() error {
				v, err := d.Str()
				s.Version = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"version\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsInfo")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00100001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDefinitionsInfo) {
					name = jsonFieldsNameOfDefinitionsInfo[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsInfo) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsInfo) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsInfoAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsInfoAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsInfoAdditional from json.
func (s *DefinitionsInfoAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsInfoAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsInfoAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsInfoAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsInfoAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsInfoPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsInfoPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsInfoPattern0 from json.
func (s *DefinitionsInfoPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsInfoPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsInfoPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsInfoPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsInfoPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesEnum as json.
func (s DefinitionsJsonschemaDraft4PropertiesEnum) Encode(e *jx.Encoder) {
	unwrapped := []jx.Raw(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	e.ArrEnd()
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesEnum from json.
func (s *DefinitionsJsonschemaDraft4PropertiesEnum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsJsonschemaDraft4PropertiesEnum to nil")
	}
	var unwrapped []jx.Raw
	if err := func() error {
		unwrapped = make([]jx.Raw, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem jx.Raw
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DefinitionsJsonschemaDraft4PropertiesEnum(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsJsonschemaDraft4PropertiesEnum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsJsonschemaDraft4PropertiesEnum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum as json.
func (s DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) Encode(e *jx.Encoder) {
	unwrapped := bool(s)
	e.Bool(unwrapped)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum from json.
func (s *DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum as json.
func (s DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) Encode(e *jx.Encoder) {
	unwrapped := bool(s)
	e.Bool(unwrapped)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum from json.
func (s *DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesMaximum as json.
func (s DefinitionsJsonschemaDraft4PropertiesMaximum) Encode(e *jx.Encoder) {
	unwrapped := float64(s)
	e.Float64(unwrapped)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesMaximum from json.
func (s *DefinitionsJsonschemaDraft4PropertiesMaximum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsJsonschemaDraft4PropertiesMaximum to nil")
	}
	var unwrapped float64
	if err := func() error {
		v, err := d.Float64()
		unwrapped = float64(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DefinitionsJsonschemaDraft4PropertiesMaximum(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsJsonschemaDraft4PropertiesMaximum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsJsonschemaDraft4PropertiesMaximum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesMinimum as json.
func (s DefinitionsJsonschemaDraft4PropertiesMinimum) Encode(e *jx.Encoder) {
	unwrapped := float64(s)
	e.Float64(unwrapped)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesMinimum from json.
func (s *DefinitionsJsonschemaDraft4PropertiesMinimum) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsJsonschemaDraft4PropertiesMinimum to nil")
	}
	var unwrapped float64
	if err := func() error {
		v, err := d.Float64()
		unwrapped = float64(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DefinitionsJsonschemaDraft4PropertiesMinimum(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsJsonschemaDraft4PropertiesMinimum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsJsonschemaDraft4PropertiesMinimum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesMultipleOf as json.
func (s DefinitionsJsonschemaDraft4PropertiesMultipleOf) Encode(e *jx.Encoder) {
	unwrapped := float64(s)
	e.Float64(unwrapped)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesMultipleOf from json.
func (s *DefinitionsJsonschemaDraft4PropertiesMultipleOf) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsJsonschemaDraft4PropertiesMultipleOf to nil")
	}
	var unwrapped float64
	if err := func() error {
		v, err := d.Float64()
		unwrapped = float64(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DefinitionsJsonschemaDraft4PropertiesMultipleOf(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsJsonschemaDraft4PropertiesMultipleOf) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsJsonschemaDraft4PropertiesMultipleOf) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesPattern as json.
func (s DefinitionsJsonschemaDraft4PropertiesPattern) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesPattern from json.
func (s *DefinitionsJsonschemaDraft4PropertiesPattern) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsJsonschemaDraft4PropertiesPattern to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DefinitionsJsonschemaDraft4PropertiesPattern(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsJsonschemaDraft4PropertiesPattern) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsJsonschemaDraft4PropertiesPattern) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesTitle as json.
func (s DefinitionsJsonschemaDraft4PropertiesTitle) Encode(e *jx.Encoder) {
	unwrapped := string(s)
	e.Str(unwrapped)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesTitle from json.
func (s *DefinitionsJsonschemaDraft4PropertiesTitle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsJsonschemaDraft4PropertiesTitle to nil")
	}
	var unwrapped string
	if err := func() error {
		v, err := d.Str()
		unwrapped = string(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DefinitionsJsonschemaDraft4PropertiesTitle(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsJsonschemaDraft4PropertiesTitle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsJsonschemaDraft4PropertiesTitle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesUniqueItems as json.
func (s DefinitionsJsonschemaDraft4PropertiesUniqueItems) Encode(e *jx.Encoder) {
	unwrapped := bool(s)
	e.Bool(unwrapped)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesUniqueItems from json.
func (s *DefinitionsJsonschemaDraft4PropertiesUniqueItems) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsJsonschemaDraft4PropertiesUniqueItems to nil")
	}
	var unwrapped bool
	if err := func() error {
		v, err := d.Bool()
		unwrapped = bool(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DefinitionsJsonschemaDraft4PropertiesUniqueItems(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsJsonschemaDraft4PropertiesUniqueItems) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsJsonschemaDraft4PropertiesUniqueItems) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsLicense) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsLicense) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.URL.Set {
			e.FieldStart("url")
			s.URL.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsLicense = [2]string{
	0: "name",
	1: "url",
}

// Decode decodes DefinitionsLicense from json.
func (s *DefinitionsLicense) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsLicense to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "url":
			if err := func() error {
				s.URL.Reset()
				if err := s.URL.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsLicense")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDefinitionsLicense) {
					name = jsonFieldsNameOfDefinitionsLicense[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsLicense) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsLicense) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsLicenseAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsLicenseAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsLicenseAdditional from json.
func (s *DefinitionsLicenseAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsLicenseAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsLicenseAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsLicenseAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsLicenseAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsLicensePattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsLicensePattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsLicensePattern0 from json.
func (s *DefinitionsLicensePattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsLicensePattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsLicensePattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsLicensePattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsLicensePattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsLink) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsLink) encodeFields(e *jx.Encoder) {
	{
		if s.OperationRef.Set {
			e.FieldStart("operationRef")
			s.OperationRef.Encode(e)
		}
	}
	{
		if s.OperationId.Set {
			e.FieldStart("operationId")
			s.OperationId.Encode(e)
		}
	}
	{
		if s.Parameters.Set {
			e.FieldStart("parameters")
			s.Parameters.Encode(e)
		}
	}
	{

		if len(s.RequestBody) != 0 {
			e.FieldStart("requestBody")
			e.Raw(s.RequestBody)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Server.Set {
			e.FieldStart("server")
			s.Server.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsLink = [6]string{
	0: "operationRef",
	1: "operationId",
	2: "parameters",
	3: "requestBody",
	4: "description",
	5: "server",
}

// Decode decodes DefinitionsLink from json.
func (s *DefinitionsLink) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsLink to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "operationRef":
			if err := func() error {
				s.OperationRef.Reset()
				if err := s.OperationRef.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationRef\"")
			}
		case "operationId":
			if err := func() error {
				s.OperationId.Reset()
				if err := s.OperationId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationId\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters.Reset()
				if err := s.Parameters.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "requestBody":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.RequestBody = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestBody\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "server":
			if err := func() error {
				s.Server.Reset()
				if err := s.Server.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"server\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsLink")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsLink) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsLink) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsLinkAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsLinkAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsLinkAdditional from json.
func (s *DefinitionsLinkAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsLinkAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsLinkAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsLinkAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsLinkAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsLinkOrReference as json.
func (s DefinitionsLinkOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case DefinitionsLinkDefinitionsLinkOrReference:
		s.DefinitionsLink.Encode(e)
	case DefinitionsReferenceDefinitionsLinkOrReference:
		s.DefinitionsReference.Encode(e)
	}
}

// Decode decodes DefinitionsLinkOrReference from json.
func (s *DefinitionsLinkOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsLinkOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "operationRef":
				found = true
				s.Type = DefinitionsLinkDefinitionsLinkOrReference
			case "operationId":
				found = true
				s.Type = DefinitionsLinkDefinitionsLinkOrReference
			case "parameters":
				found = true
				s.Type = DefinitionsLinkDefinitionsLinkOrReference
			case "requestBody":
				found = true
				s.Type = DefinitionsLinkDefinitionsLinkOrReference
			case "description":
				found = true
				s.Type = DefinitionsLinkDefinitionsLinkOrReference
			case "server":
				found = true
				s.Type = DefinitionsLinkDefinitionsLinkOrReference
			case "$ref":
				found = true
				s.Type = DefinitionsReferenceDefinitionsLinkOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DefinitionsLinkDefinitionsLinkOrReference:
		if err := s.DefinitionsLink.Decode(d); err != nil {
			return err
		}
	case DefinitionsReferenceDefinitionsLinkOrReference:
		if err := s.DefinitionsReference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsLinkOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsLinkOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsLinkPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsLinkPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsLinkPattern0 from json.
func (s *DefinitionsLinkPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsLinkPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsLinkPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsLinkPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsLinkPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsLinksOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsLinksOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsLinksOrReferences from json.
func (s *DefinitionsLinksOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsLinksOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DefinitionsLinkOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsLinksOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsLinksOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsLinksOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsMediaType) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsMediaType) encodeFields(e *jx.Encoder) {
	{
		if s.Schema.Set {
			e.FieldStart("schema")
			s.Schema.Encode(e)
		}
	}
	{

		if len(s.Example) != 0 {
			e.FieldStart("example")
			e.Raw(s.Example)
		}
	}
	{
		if s.Examples.Set {
			e.FieldStart("examples")
			s.Examples.Encode(e)
		}
	}
	{
		if s.Encoding.Set {
			e.FieldStart("encoding")
			s.Encoding.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsMediaType = [4]string{
	0: "schema",
	1: "example",
	2: "examples",
	3: "encoding",
}

// Decode decodes DefinitionsMediaType from json.
func (s *DefinitionsMediaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsMediaType to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "schema":
			if err := func() error {
				s.Schema.Reset()
				if err := s.Schema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		case "example":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Example = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"example\"")
			}
		case "examples":
			if err := func() error {
				s.Examples.Reset()
				if err := s.Examples.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"examples\"")
			}
		case "encoding":
			if err := func() error {
				s.Encoding.Reset()
				if err := s.Encoding.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"encoding\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsMediaType")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsMediaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsMediaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsMediaTypeAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsMediaTypeAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsMediaTypeAdditional from json.
func (s *DefinitionsMediaTypeAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsMediaTypeAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsMediaTypeAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsMediaTypeAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsMediaTypeAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsMediaTypePattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsMediaTypePattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsMediaTypePattern0 from json.
func (s *DefinitionsMediaTypePattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsMediaTypePattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsMediaTypePattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsMediaTypePattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsMediaTypePattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsMediaTypes) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsMediaTypes) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsMediaTypes from json.
func (s *DefinitionsMediaTypes) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsMediaTypes to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DefinitionsMediaType
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsMediaTypes")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsMediaTypes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsMediaTypes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsOauthFlow) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsOauthFlow) encodeFields(e *jx.Encoder) {
	{
		if s.AuthorizationUrl.Set {
			e.FieldStart("authorizationUrl")
			s.AuthorizationUrl.Encode(e)
		}
	}
	{
		if s.TokenUrl.Set {
			e.FieldStart("tokenUrl")
			s.TokenUrl.Encode(e)
		}
	}
	{
		if s.RefreshUrl.Set {
			e.FieldStart("refreshUrl")
			s.RefreshUrl.Encode(e)
		}
	}
	{
		if s.Scopes.Set {
			e.FieldStart("scopes")
			s.Scopes.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsOauthFlow = [4]string{
	0: "authorizationUrl",
	1: "tokenUrl",
	2: "refreshUrl",
	3: "scopes",
}

// Decode decodes DefinitionsOauthFlow from json.
func (s *DefinitionsOauthFlow) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsOauthFlow to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "authorizationUrl":
			if err := func() error {
				s.AuthorizationUrl.Reset()
				if err := s.AuthorizationUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizationUrl\"")
			}
		case "tokenUrl":
			if err := func() error {
				s.TokenUrl.Reset()
				if err := s.TokenUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tokenUrl\"")
			}
		case "refreshUrl":
			if err := func() error {
				s.RefreshUrl.Reset()
				if err := s.RefreshUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"refreshUrl\"")
			}
		case "scopes":
			if err := func() error {
				s.Scopes.Reset()
				if err := s.Scopes.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scopes\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsOauthFlow")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsOauthFlow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsOauthFlow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsOauthFlowAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsOauthFlowAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsOauthFlowAdditional from json.
func (s *DefinitionsOauthFlowAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsOauthFlowAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsOauthFlowAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsOauthFlowAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsOauthFlowAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsOauthFlowPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsOauthFlowPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsOauthFlowPattern0 from json.
func (s *DefinitionsOauthFlowPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsOauthFlowPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsOauthFlowPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsOauthFlowPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsOauthFlowPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsOauthFlows) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsOauthFlows) encodeFields(e *jx.Encoder) {
	{
		if s.Implicit.Set {
			e.FieldStart("implicit")
			s.Implicit.Encode(e)
		}
	}
	{
		if s.Password.Set {
			e.FieldStart("password")
			s.Password.Encode(e)
		}
	}
	{
		if s.ClientCredentials.Set {
			e.FieldStart("clientCredentials")
			s.ClientCredentials.Encode(e)
		}
	}
	{
		if s.AuthorizationCode.Set {
			e.FieldStart("authorizationCode")
			s.AuthorizationCode.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsOauthFlows = [4]string{
	0: "implicit",
	1: "password",
	2: "clientCredentials",
	3: "authorizationCode",
}

// Decode decodes DefinitionsOauthFlows from json.
func (s *DefinitionsOauthFlows) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsOauthFlows to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "implicit":
			if err := func() error {
				s.Implicit.Reset()
				if err := s.Implicit.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"implicit\"")
			}
		case "password":
			if err := func() error {
				s.Password.Reset()
				if err := s.Password.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"password\"")
			}
		case "clientCredentials":
			if err := func() error {
				s.ClientCredentials.Reset()
				if err := s.ClientCredentials.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"clientCredentials\"")
			}
		case "authorizationCode":
			if err := func() error {
				s.AuthorizationCode.Reset()
				if err := s.AuthorizationCode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"authorizationCode\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsOauthFlows")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsOauthFlows) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsOauthFlows) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsOauthFlowsAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsOauthFlowsAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsOauthFlowsAdditional from json.
func (s *DefinitionsOauthFlowsAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsOauthFlowsAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsOauthFlowsAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsOauthFlowsAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsOauthFlowsAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsOauthFlowsPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsOauthFlowsPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsOauthFlowsPattern0 from json.
func (s *DefinitionsOauthFlowsPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsOauthFlowsPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsOauthFlowsPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsOauthFlowsPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsOauthFlowsPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsOperation) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsOperation) encodeFields(e *jx.Encoder) {
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ExternalDocs.Set {
			e.FieldStart("externalDocs")
			s.ExternalDocs.Encode(e)
		}
	}
	{
		if s.OperationId.Set {
			e.FieldStart("operationId")
			s.OperationId.Encode(e)
		}
	}
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			e.ArrStart()
			for _, elem := range s.Parameters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.RequestBody.Set {
			e.FieldStart("requestBody")
			s.RequestBody.Encode(e)
		}
	}
	{

		e.FieldStart("responses")
		s.Responses.Encode(e)
	}
	{
		if s.Callbacks.Set {
			e.FieldStart("callbacks")
			s.Callbacks.Encode(e)
		}
	}
	{
		if s.Deprecated.Set {
			e.FieldStart("deprecated")
			s.Deprecated.Encode(e)
		}
	}
	{
		if s.Security != nil {
			e.FieldStart("security")
			e.ArrStart()
			for _, elem := range s.Security {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Servers != nil {
			e.FieldStart("servers")
			e.ArrStart()
			for _, elem := range s.Servers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsOperation = [12]string{
	0:  "tags",
	1:  "summary",
	2:  "description",
	3:  "externalDocs",
	4:  "operationId",
	5:  "parameters",
	6:  "requestBody",
	7:  "responses",
	8:  "callbacks",
	9:  "deprecated",
	10: "security",
	11: "servers",
}

// Decode decodes DefinitionsOperation from json.
func (s *DefinitionsOperation) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsOperation to nil")
	}
	var requiredBitSet [2]uint8
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "tags":
			if err := func() error {
				s.Tags = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "externalDocs":
			if err := func() error {
				s.ExternalDocs.Reset()
				if err := s.ExternalDocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalDocs\"")
			}
		case "operationId":
			if err := func() error {
				s.OperationId.Reset()
				if err := s.OperationId.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"operationId\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters = make([]DefinitionsParameterOrReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DefinitionsParameterOrReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parameters = append(s.Parameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		case "requestBody":
			if err := func() error {
				s.RequestBody.Reset()
				if err := s.RequestBody.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"requestBody\"")
			}
		case "responses":
			requiredBitSet[0] |= 1 << 7
			if err := func() error {
				if err := s.Responses.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"responses\"")
			}
		case "callbacks":
			if err := func() error {
				s.Callbacks.Reset()
				if err := s.Callbacks.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"callbacks\"")
			}
		case "deprecated":
			if err := func() error {
				s.Deprecated.Reset()
				if err := s.Deprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecated\"")
			}
		case "security":
			if err := func() error {
				s.Security = make([]DefinitionsSecurityRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DefinitionsSecurityRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Security = append(s.Security, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "servers":
			if err := func() error {
				s.Servers = make([]DefinitionsServer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DefinitionsServer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Servers = append(s.Servers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servers\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsOperation")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b10000000,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDefinitionsOperation) {
					name = jsonFieldsNameOfDefinitionsOperation[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsOperation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsOperation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsOperationAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsOperationAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsOperationAdditional from json.
func (s *DefinitionsOperationAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsOperationAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsOperationAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsOperationAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsOperationAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsOperationPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsOperationPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsOperationPattern0 from json.
func (s *DefinitionsOperationPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsOperationPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsOperationPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsOperationPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsOperationPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsParameter) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsParameter) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{

		e.FieldStart("in")
		s.In.Encode(e)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Required.Set {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
	{
		if s.Deprecated.Set {
			e.FieldStart("deprecated")
			s.Deprecated.Encode(e)
		}
	}
	{
		if s.AllowEmptyValue.Set {
			e.FieldStart("allowEmptyValue")
			s.AllowEmptyValue.Encode(e)
		}
	}
	{
		if s.Style.Set {
			e.FieldStart("style")
			s.Style.Encode(e)
		}
	}
	{
		if s.Explode.Set {
			e.FieldStart("explode")
			s.Explode.Encode(e)
		}
	}
	{
		if s.AllowReserved.Set {
			e.FieldStart("allowReserved")
			s.AllowReserved.Encode(e)
		}
	}
	{
		if s.Schema.Set {
			e.FieldStart("schema")
			s.Schema.Encode(e)
		}
	}
	{

		if len(s.Example) != 0 {
			e.FieldStart("example")
			e.Raw(s.Example)
		}
	}
	{
		if s.Examples.Set {
			e.FieldStart("examples")
			s.Examples.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsParameter = [13]string{
	0:  "name",
	1:  "in",
	2:  "description",
	3:  "required",
	4:  "deprecated",
	5:  "allowEmptyValue",
	6:  "style",
	7:  "explode",
	8:  "allowReserved",
	9:  "schema",
	10: "example",
	11: "examples",
	12: "content",
}

// Decode decodes DefinitionsParameter from json.
func (s *DefinitionsParameter) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsParameter to nil")
	}
	var requiredBitSet [2]uint8
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "in":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.In.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"in\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		case "deprecated":
			if err := func() error {
				s.Deprecated.Reset()
				if err := s.Deprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecated\"")
			}
		case "allowEmptyValue":
			if err := func() error {
				s.AllowEmptyValue.Reset()
				if err := s.AllowEmptyValue.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowEmptyValue\"")
			}
		case "style":
			if err := func() error {
				s.Style.Reset()
				if err := s.Style.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"style\"")
			}
		case "explode":
			if err := func() error {
				s.Explode.Reset()
				if err := s.Explode.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"explode\"")
			}
		case "allowReserved":
			if err := func() error {
				s.AllowReserved.Reset()
				if err := s.AllowReserved.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allowReserved\"")
			}
		case "schema":
			if err := func() error {
				s.Schema.Reset()
				if err := s.Schema.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"schema\"")
			}
		case "example":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Example = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"example\"")
			}
		case "examples":
			if err := func() error {
				s.Examples.Reset()
				if err := s.Examples.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"examples\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsParameter")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [2]uint8{
		0b00000011,
		0b00000000,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDefinitionsParameter) {
					name = jsonFieldsNameOfDefinitionsParameter[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsParameter) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsParameter) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsParameterAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsParameterAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsParameterAdditional from json.
func (s *DefinitionsParameterAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsParameterAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsParameterAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsParameterAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsParameterAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsParameterIn as json.
func (s DefinitionsParameterIn) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DefinitionsParameterIn from json.
func (s *DefinitionsParameterIn) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsParameterIn to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DefinitionsParameterIn(v) {
	case DefinitionsParameterInPath:
		*s = DefinitionsParameterInPath
	case DefinitionsParameterInQuery:
		*s = DefinitionsParameterInQuery
	case DefinitionsParameterInCookie:
		*s = DefinitionsParameterInCookie
	case DefinitionsParameterInHeader:
		*s = DefinitionsParameterInHeader
	default:
		*s = DefinitionsParameterIn(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsParameterIn) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsParameterIn) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsParameterOrReference as json.
func (s DefinitionsParameterOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case DefinitionsParameterDefinitionsParameterOrReference:
		s.DefinitionsParameter.Encode(e)
	case DefinitionsReferenceDefinitionsParameterOrReference:
		s.DefinitionsReference.Encode(e)
	}
}

// Decode decodes DefinitionsParameterOrReference from json.
func (s *DefinitionsParameterOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsParameterOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "name":
				found = true
				s.Type = DefinitionsParameterDefinitionsParameterOrReference
			case "in":
				found = true
				s.Type = DefinitionsParameterDefinitionsParameterOrReference
			case "description":
				found = true
				s.Type = DefinitionsParameterDefinitionsParameterOrReference
			case "required":
				found = true
				s.Type = DefinitionsParameterDefinitionsParameterOrReference
			case "deprecated":
				found = true
				s.Type = DefinitionsParameterDefinitionsParameterOrReference
			case "allowEmptyValue":
				found = true
				s.Type = DefinitionsParameterDefinitionsParameterOrReference
			case "style":
				found = true
				s.Type = DefinitionsParameterDefinitionsParameterOrReference
			case "explode":
				found = true
				s.Type = DefinitionsParameterDefinitionsParameterOrReference
			case "allowReserved":
				found = true
				s.Type = DefinitionsParameterDefinitionsParameterOrReference
			case "schema":
				found = true
				s.Type = DefinitionsParameterDefinitionsParameterOrReference
			case "example":
				found = true
				s.Type = DefinitionsParameterDefinitionsParameterOrReference
			case "examples":
				found = true
				s.Type = DefinitionsParameterDefinitionsParameterOrReference
			case "content":
				found = true
				s.Type = DefinitionsParameterDefinitionsParameterOrReference
			case "$ref":
				found = true
				s.Type = DefinitionsReferenceDefinitionsParameterOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DefinitionsParameterDefinitionsParameterOrReference:
		if err := s.DefinitionsParameter.Decode(d); err != nil {
			return err
		}
	case DefinitionsReferenceDefinitionsParameterOrReference:
		if err := s.DefinitionsReference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsParameterOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsParameterOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsParameterPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsParameterPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsParameterPattern0 from json.
func (s *DefinitionsParameterPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsParameterPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsParameterPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsParameterPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsParameterPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsParameterStyle as json.
func (s DefinitionsParameterStyle) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DefinitionsParameterStyle from json.
func (s *DefinitionsParameterStyle) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsParameterStyle to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DefinitionsParameterStyle(v) {
	case DefinitionsParameterStyleMatrix:
		*s = DefinitionsParameterStyleMatrix
	case DefinitionsParameterStyleLabel:
		*s = DefinitionsParameterStyleLabel
	case DefinitionsParameterStyleForm:
		*s = DefinitionsParameterStyleForm
	case DefinitionsParameterStyleSimple:
		*s = DefinitionsParameterStyleSimple
	case DefinitionsParameterStyleSpaceDelimited:
		*s = DefinitionsParameterStyleSpaceDelimited
	case DefinitionsParameterStylePipeDelimited:
		*s = DefinitionsParameterStylePipeDelimited
	case DefinitionsParameterStyleDeepObject:
		*s = DefinitionsParameterStyleDeepObject
	default:
		*s = DefinitionsParameterStyle(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsParameterStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsParameterStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsParametersOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsParametersOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsParametersOrReferences from json.
func (s *DefinitionsParametersOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsParametersOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DefinitionsParameterOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsParametersOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsParametersOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsParametersOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsPathItem) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsPathItem) encodeFields(e *jx.Encoder) {
	{
		if s.Ref.Set {
			e.FieldStart("$ref")
			s.Ref.Encode(e)
		}
	}
	{
		if s.Summary.Set {
			e.FieldStart("summary")
			s.Summary.Encode(e)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Get.Set {
			e.FieldStart("get")
			s.Get.Encode(e)
		}
	}
	{
		if s.Put.Set {
			e.FieldStart("put")
			s.Put.Encode(e)
		}
	}
	{
		if s.Post.Set {
			e.FieldStart("post")
			s.Post.Encode(e)
		}
	}
	{
		if s.Delete.Set {
			e.FieldStart("delete")
			s.Delete.Encode(e)
		}
	}
	{
		if s.Options.Set {
			e.FieldStart("options")
			s.Options.Encode(e)
		}
	}
	{
		if s.Head.Set {
			e.FieldStart("head")
			s.Head.Encode(e)
		}
	}
	{
		if s.Patch.Set {
			e.FieldStart("patch")
			s.Patch.Encode(e)
		}
	}
	{
		if s.Trace.Set {
			e.FieldStart("trace")
			s.Trace.Encode(e)
		}
	}
	{
		if s.Servers != nil {
			e.FieldStart("servers")
			e.ArrStart()
			for _, elem := range s.Servers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Parameters != nil {
			e.FieldStart("parameters")
			e.ArrStart()
			for _, elem := range s.Parameters {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsPathItem = [13]string{
	0:  "$ref",
	1:  "summary",
	2:  "description",
	3:  "get",
	4:  "put",
	5:  "post",
	6:  "delete",
	7:  "options",
	8:  "head",
	9:  "patch",
	10: "trace",
	11: "servers",
	12: "parameters",
}

// Decode decodes DefinitionsPathItem from json.
func (s *DefinitionsPathItem) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsPathItem to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "$ref":
			if err := func() error {
				s.Ref.Reset()
				if err := s.Ref.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"$ref\"")
			}
		case "summary":
			if err := func() error {
				s.Summary.Reset()
				if err := s.Summary.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"summary\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "get":
			if err := func() error {
				s.Get.Reset()
				if err := s.Get.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"get\"")
			}
		case "put":
			if err := func() error {
				s.Put.Reset()
				if err := s.Put.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"put\"")
			}
		case "post":
			if err := func() error {
				s.Post.Reset()
				if err := s.Post.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"post\"")
			}
		case "delete":
			if err := func() error {
				s.Delete.Reset()
				if err := s.Delete.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"delete\"")
			}
		case "options":
			if err := func() error {
				s.Options.Reset()
				if err := s.Options.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"options\"")
			}
		case "head":
			if err := func() error {
				s.Head.Reset()
				if err := s.Head.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"head\"")
			}
		case "patch":
			if err := func() error {
				s.Patch.Reset()
				if err := s.Patch.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"patch\"")
			}
		case "trace":
			if err := func() error {
				s.Trace.Reset()
				if err := s.Trace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"trace\"")
			}
		case "servers":
			if err := func() error {
				s.Servers = make([]DefinitionsServer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DefinitionsServer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Servers = append(s.Servers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servers\"")
			}
		case "parameters":
			if err := func() error {
				s.Parameters = make([]DefinitionsParameterOrReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DefinitionsParameterOrReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Parameters = append(s.Parameters, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"parameters\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsPathItem")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsPathItem) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsPathItem) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsPathItemAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsPathItemAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsPathItemAdditional from json.
func (s *DefinitionsPathItemAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsPathItemAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsPathItemAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsPathItemAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsPathItemAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsPathItemPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsPathItemPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsPathItemPattern0 from json.
func (s *DefinitionsPathItemPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsPathItemPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsPathItemPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsPathItemPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsPathItemPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsPaths) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsPaths) encodeFields(e *jx.Encoder) {
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		elem.Encode(e)
	}
	for k, elem := range s.Pattern1Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsPaths = [0]string{}

// Decode decodes DefinitionsPaths from json.
func (s *DefinitionsPaths) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsPaths to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]DefinitionsPathItem{}
	s.Pattern1Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var handled bool
			if pattern := regexMap["^/"]; pattern.Match(k) {
				handled = true
				var elem DefinitionsPathItem
				if err := func() error {
					if err := elem.Decode(d); err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern1Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsPaths")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsPaths) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsPaths) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsPathsAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsPathsAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsPathsAdditional from json.
func (s *DefinitionsPathsAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsPathsAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsPathsAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsPathsAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsPathsAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsPathsPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsPathsPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsPathsPattern0 from json.
func (s *DefinitionsPathsPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsPathsPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^/"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem DefinitionsPathItem
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsPathsPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsPathsPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsPathsPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsPathsPattern1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsPathsPattern1) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsPathsPattern1 from json.
func (s *DefinitionsPathsPattern1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsPathsPattern1 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsPathsPattern1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsPathsPattern1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsPathsPattern1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsPositiveInteger as json.
func (s DefinitionsPositiveInteger) Encode(e *jx.Encoder) {
	unwrapped := int(s)
	e.Int(unwrapped)
}

// Decode decodes DefinitionsPositiveInteger from json.
func (s *DefinitionsPositiveInteger) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsPositiveInteger to nil")
	}
	var unwrapped int
	if err := func() error {
		v, err := d.Int()
		unwrapped = int(v)
		if err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DefinitionsPositiveInteger(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsPositiveInteger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsPositiveInteger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsReference) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsReference) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("$ref")
		e.Str(s.Ref)
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsReference = [1]string{
	0: "$ref",
}

// Decode decodes DefinitionsReference from json.
func (s *DefinitionsReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsReference to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "$ref":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Ref = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"$ref\"")
			}
		default:
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsReference")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDefinitionsReference) {
					name = jsonFieldsNameOfDefinitionsReference[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsReferenceAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsReferenceAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsReferenceAdditional from json.
func (s *DefinitionsReferenceAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsReferenceAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsReferenceAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsReferenceAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsReferenceAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsRequestBodiesOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsRequestBodiesOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsRequestBodiesOrReferences from json.
func (s *DefinitionsRequestBodiesOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsRequestBodiesOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DefinitionsRequestBodyOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsRequestBodiesOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsRequestBodiesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsRequestBodiesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsRequestBody) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsRequestBody) encodeFields(e *jx.Encoder) {
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{

		e.FieldStart("content")
		s.Content.Encode(e)
	}
	{
		if s.Required.Set {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsRequestBody = [3]string{
	0: "description",
	1: "content",
	2: "required",
}

// Decode decodes DefinitionsRequestBody from json.
func (s *DefinitionsRequestBody) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsRequestBody to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "content":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "required":
			if err := func() error {
				s.Required.Reset()
				if err := s.Required.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsRequestBody")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDefinitionsRequestBody) {
					name = jsonFieldsNameOfDefinitionsRequestBody[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsRequestBody) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsRequestBody) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsRequestBodyAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsRequestBodyAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsRequestBodyAdditional from json.
func (s *DefinitionsRequestBodyAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsRequestBodyAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsRequestBodyAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsRequestBodyAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsRequestBodyAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsRequestBodyOrReference as json.
func (s DefinitionsRequestBodyOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case DefinitionsRequestBodyDefinitionsRequestBodyOrReference:
		s.DefinitionsRequestBody.Encode(e)
	case DefinitionsReferenceDefinitionsRequestBodyOrReference:
		s.DefinitionsReference.Encode(e)
	}
}

// Decode decodes DefinitionsRequestBodyOrReference from json.
func (s *DefinitionsRequestBodyOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsRequestBodyOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "description":
				found = true
				s.Type = DefinitionsRequestBodyDefinitionsRequestBodyOrReference
			case "content":
				found = true
				s.Type = DefinitionsRequestBodyDefinitionsRequestBodyOrReference
			case "required":
				found = true
				s.Type = DefinitionsRequestBodyDefinitionsRequestBodyOrReference
			case "$ref":
				found = true
				s.Type = DefinitionsReferenceDefinitionsRequestBodyOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DefinitionsRequestBodyDefinitionsRequestBodyOrReference:
		if err := s.DefinitionsRequestBody.Decode(d); err != nil {
			return err
		}
	case DefinitionsReferenceDefinitionsRequestBodyOrReference:
		if err := s.DefinitionsReference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsRequestBodyOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsRequestBodyOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsRequestBodyPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsRequestBodyPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsRequestBodyPattern0 from json.
func (s *DefinitionsRequestBodyPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsRequestBodyPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsRequestBodyPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsRequestBodyPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsRequestBodyPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsResponse) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsResponse) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("description")
		e.Str(s.Description)
	}
	{
		if s.Headers.Set {
			e.FieldStart("headers")
			s.Headers.Encode(e)
		}
	}
	{
		if s.Content.Set {
			e.FieldStart("content")
			s.Content.Encode(e)
		}
	}
	{
		if s.Links.Set {
			e.FieldStart("links")
			s.Links.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsResponse = [4]string{
	0: "description",
	1: "headers",
	2: "content",
	3: "links",
}

// Decode decodes DefinitionsResponse from json.
func (s *DefinitionsResponse) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsResponse to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "description":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Description = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "headers":
			if err := func() error {
				s.Headers.Reset()
				if err := s.Headers.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"headers\"")
			}
		case "content":
			if err := func() error {
				s.Content.Reset()
				if err := s.Content.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"content\"")
			}
		case "links":
			if err := func() error {
				s.Links.Reset()
				if err := s.Links.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"links\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsResponse")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDefinitionsResponse) {
					name = jsonFieldsNameOfDefinitionsResponse[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsResponse) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsResponse) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsResponseAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsResponseAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsResponseAdditional from json.
func (s *DefinitionsResponseAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsResponseAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsResponseAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsResponseAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsResponseAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsResponseOrReference as json.
func (s DefinitionsResponseOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case DefinitionsResponseDefinitionsResponseOrReference:
		s.DefinitionsResponse.Encode(e)
	case DefinitionsReferenceDefinitionsResponseOrReference:
		s.DefinitionsReference.Encode(e)
	}
}

// Decode decodes DefinitionsResponseOrReference from json.
func (s *DefinitionsResponseOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsResponseOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "description":
				found = true
				s.Type = DefinitionsResponseDefinitionsResponseOrReference
			case "headers":
				found = true
				s.Type = DefinitionsResponseDefinitionsResponseOrReference
			case "content":
				found = true
				s.Type = DefinitionsResponseDefinitionsResponseOrReference
			case "links":
				found = true
				s.Type = DefinitionsResponseDefinitionsResponseOrReference
			case "$ref":
				found = true
				s.Type = DefinitionsReferenceDefinitionsResponseOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DefinitionsResponseDefinitionsResponseOrReference:
		if err := s.DefinitionsResponse.Decode(d); err != nil {
			return err
		}
	case DefinitionsReferenceDefinitionsResponseOrReference:
		if err := s.DefinitionsReference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsResponseOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsResponseOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsResponsePattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsResponsePattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsResponsePattern0 from json.
func (s *DefinitionsResponsePattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsResponsePattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsResponsePattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsResponsePattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsResponsePattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsResponses) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsResponses) encodeFields(e *jx.Encoder) {
	{
		if s.Default.Set {
			e.FieldStart("default")
			s.Default.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		elem.Encode(e)
	}
	for k, elem := range s.Pattern1Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsResponses = [1]string{
	0: "default",
}

// Decode decodes DefinitionsResponses from json.
func (s *DefinitionsResponses) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsResponses to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]DefinitionsResponseOrReference{}
	s.Pattern1Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "default":
			if err := func() error {
				s.Default.Reset()
				if err := s.Default.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^([0-9X]{3})$"]; pattern.Match(k) {
				handled = true
				var elem DefinitionsResponseOrReference
				if err := func() error {
					if err := elem.Decode(d); err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern1Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsResponses")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsResponses) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsResponses) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsResponsesAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsResponsesAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsResponsesAdditional from json.
func (s *DefinitionsResponsesAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsResponsesAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsResponsesAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsResponsesAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsResponsesAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsResponsesOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsResponsesOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsResponsesOrReferences from json.
func (s *DefinitionsResponsesOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsResponsesOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DefinitionsResponseOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsResponsesOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsResponsesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsResponsesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsResponsesPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsResponsesPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsResponsesPattern0 from json.
func (s *DefinitionsResponsesPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsResponsesPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^([0-9X]{3})$"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem DefinitionsResponseOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsResponsesPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsResponsesPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsResponsesPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsResponsesPattern1) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsResponsesPattern1) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsResponsesPattern1 from json.
func (s *DefinitionsResponsesPattern1) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsResponsesPattern1 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsResponsesPattern1")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsResponsesPattern1) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsResponsesPattern1) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsSchema) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsSchema) encodeFields(e *jx.Encoder) {
	{
		if s.Nullable.Set {
			e.FieldStart("nullable")
			s.Nullable.Encode(e)
		}
	}
	{
		if s.Discriminator.Set {
			e.FieldStart("discriminator")
			s.Discriminator.Encode(e)
		}
	}
	{
		if s.ReadOnly.Set {
			e.FieldStart("readOnly")
			s.ReadOnly.Encode(e)
		}
	}
	{
		if s.WriteOnly.Set {
			e.FieldStart("writeOnly")
			s.WriteOnly.Encode(e)
		}
	}
	{
		if s.XML.Set {
			e.FieldStart("xml")
			s.XML.Encode(e)
		}
	}
	{
		if s.ExternalDocs.Set {
			e.FieldStart("externalDocs")
			s.ExternalDocs.Encode(e)
		}
	}
	{

		if len(s.Example) != 0 {
			e.FieldStart("example")
			e.Raw(s.Example)
		}
	}
	{
		if s.Deprecated.Set {
			e.FieldStart("deprecated")
			s.Deprecated.Encode(e)
		}
	}
	{
		if s.Title.Set {
			e.FieldStart("title")
			s.Title.Encode(e)
		}
	}
	{
		if s.MultipleOf.Set {
			e.FieldStart("multipleOf")
			s.MultipleOf.Encode(e)
		}
	}
	{
		if s.Maximum.Set {
			e.FieldStart("maximum")
			s.Maximum.Encode(e)
		}
	}
	{
		if s.ExclusiveMaximum.Set {
			e.FieldStart("exclusiveMaximum")
			s.ExclusiveMaximum.Encode(e)
		}
	}
	{
		if s.Minimum.Set {
			e.FieldStart("minimum")
			s.Minimum.Encode(e)
		}
	}
	{
		if s.ExclusiveMinimum.Set {
			e.FieldStart("exclusiveMinimum")
			s.ExclusiveMinimum.Encode(e)
		}
	}
	{
		if s.MaxLength.Set {
			e.FieldStart("maxLength")
			s.MaxLength.Encode(e)
		}
	}
	{
		if s.MinLength.Set {
			e.FieldStart("minLength")
			s.MinLength.Encode(e)
		}
	}
	{
		if s.Pattern.Set {
			e.FieldStart("pattern")
			s.Pattern.Encode(e)
		}
	}
	{
		if s.MaxItems.Set {
			e.FieldStart("maxItems")
			s.MaxItems.Encode(e)
		}
	}
	{
		if s.MinItems.Set {
			e.FieldStart("minItems")
			s.MinItems.Encode(e)
		}
	}
	{
		if s.UniqueItems.Set {
			e.FieldStart("uniqueItems")
			s.UniqueItems.Encode(e)
		}
	}
	{
		if s.MaxProperties.Set {
			e.FieldStart("maxProperties")
			s.MaxProperties.Encode(e)
		}
	}
	{
		if s.MinProperties.Set {
			e.FieldStart("minProperties")
			s.MinProperties.Encode(e)
		}
	}
	{
		if s.Required != nil {
			e.FieldStart("required")
			s.Required.Encode(e)
		}
	}
	{
		if s.Enum != nil {
			e.FieldStart("enum")
			s.Enum.Encode(e)
		}
	}
	{
		if s.Type.Set {
			e.FieldStart("type")
			s.Type.Encode(e)
		}
	}
	{
		if s.AllOf != nil {
			e.FieldStart("allOf")
			e.ArrStart()
			for _, elem := range s.AllOf {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.OneOf != nil {
			e.FieldStart("oneOf")
			e.ArrStart()
			for _, elem := range s.OneOf {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.AnyOf != nil {
			e.FieldStart("anyOf")
			e.ArrStart()
			for _, elem := range s.AnyOf {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Not != nil {
			e.FieldStart("not")
			s.Not.Encode(e)
		}
	}
	{
		if s.Items != nil {
			e.FieldStart("items")
			s.Items.Encode(e)
		}
	}
	{
		if s.Properties.Set {
			e.FieldStart("properties")
			s.Properties.Encode(e)
		}
	}
	{
		if s.AdditionalProperties != nil {
			e.FieldStart("additionalProperties")
			s.AdditionalProperties.Encode(e)
		}
	}
	{

		if len(s.Default) != 0 {
			e.FieldStart("default")
			e.Raw(s.Default)
		}
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Format.Set {
			e.FieldStart("format")
			s.Format.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsSchema = [35]string{
	0:  "nullable",
	1:  "discriminator",
	2:  "readOnly",
	3:  "writeOnly",
	4:  "xml",
	5:  "externalDocs",
	6:  "example",
	7:  "deprecated",
	8:  "title",
	9:  "multipleOf",
	10: "maximum",
	11: "exclusiveMaximum",
	12: "minimum",
	13: "exclusiveMinimum",
	14: "maxLength",
	15: "minLength",
	16: "pattern",
	17: "maxItems",
	18: "minItems",
	19: "uniqueItems",
	20: "maxProperties",
	21: "minProperties",
	22: "required",
	23: "enum",
	24: "type",
	25: "allOf",
	26: "oneOf",
	27: "anyOf",
	28: "not",
	29: "items",
	30: "properties",
	31: "additionalProperties",
	32: "default",
	33: "description",
	34: "format",
}

// Decode decodes DefinitionsSchema from json.
func (s *DefinitionsSchema) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSchema to nil")
	}
	s.setDefaults()
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "nullable":
			if err := func() error {
				s.Nullable.Reset()
				if err := s.Nullable.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"nullable\"")
			}
		case "discriminator":
			if err := func() error {
				s.Discriminator.Reset()
				if err := s.Discriminator.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"discriminator\"")
			}
		case "readOnly":
			if err := func() error {
				s.ReadOnly.Reset()
				if err := s.ReadOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"readOnly\"")
			}
		case "writeOnly":
			if err := func() error {
				s.WriteOnly.Reset()
				if err := s.WriteOnly.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"writeOnly\"")
			}
		case "xml":
			if err := func() error {
				s.XML.Reset()
				if err := s.XML.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"xml\"")
			}
		case "externalDocs":
			if err := func() error {
				s.ExternalDocs.Reset()
				if err := s.ExternalDocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalDocs\"")
			}
		case "example":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Example = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"example\"")
			}
		case "deprecated":
			if err := func() error {
				s.Deprecated.Reset()
				if err := s.Deprecated.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"deprecated\"")
			}
		case "title":
			if err := func() error {
				s.Title.Reset()
				if err := s.Title.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"title\"")
			}
		case "multipleOf":
			if err := func() error {
				s.MultipleOf.Reset()
				if err := s.MultipleOf.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"multipleOf\"")
			}
		case "maximum":
			if err := func() error {
				s.Maximum.Reset()
				if err := s.Maximum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maximum\"")
			}
		case "exclusiveMaximum":
			if err := func() error {
				s.ExclusiveMaximum.Reset()
				if err := s.ExclusiveMaximum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclusiveMaximum\"")
			}
		case "minimum":
			if err := func() error {
				s.Minimum.Reset()
				if err := s.Minimum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minimum\"")
			}
		case "exclusiveMinimum":
			if err := func() error {
				s.ExclusiveMinimum.Reset()
				if err := s.ExclusiveMinimum.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"exclusiveMinimum\"")
			}
		case "maxLength":
			if err := func() error {
				s.MaxLength.Reset()
				if err := s.MaxLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxLength\"")
			}
		case "minLength":
			if err := func() error {
				s.MinLength.Reset()
				if err := s.MinLength.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minLength\"")
			}
		case "pattern":
			if err := func() error {
				s.Pattern.Reset()
				if err := s.Pattern.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"pattern\"")
			}
		case "maxItems":
			if err := func() error {
				s.MaxItems.Reset()
				if err := s.MaxItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxItems\"")
			}
		case "minItems":
			if err := func() error {
				s.MinItems.Reset()
				if err := s.MinItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minItems\"")
			}
		case "uniqueItems":
			if err := func() error {
				s.UniqueItems.Reset()
				if err := s.UniqueItems.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"uniqueItems\"")
			}
		case "maxProperties":
			if err := func() error {
				s.MaxProperties.Reset()
				if err := s.MaxProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"maxProperties\"")
			}
		case "minProperties":
			if err := func() error {
				s.MinProperties.Reset()
				if err := s.MinProperties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"minProperties\"")
			}
		case "required":
			if err := func() error {
				s.Required = nil
				var elem DefinitionsStringArray
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Required = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"required\"")
			}
		case "enum":
			if err := func() error {
				s.Enum = nil
				var elem DefinitionsJsonschemaDraft4PropertiesEnum
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Enum = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enum\"")
			}
		case "type":
			if err := func() error {
				s.Type.Reset()
				if err := s.Type.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "allOf":
			if err := func() error {
				s.AllOf = make([]DefinitionsSchemaOrReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DefinitionsSchemaOrReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AllOf = append(s.AllOf, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"allOf\"")
			}
		case "oneOf":
			if err := func() error {
				s.OneOf = make([]DefinitionsSchemaOrReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DefinitionsSchemaOrReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.OneOf = append(s.OneOf, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"oneOf\"")
			}
		case "anyOf":
			if err := func() error {
				s.AnyOf = make([]DefinitionsSchemaOrReference, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DefinitionsSchemaOrReference
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.AnyOf = append(s.AnyOf, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"anyOf\"")
			}
		case "not":
			if err := func() error {
				s.Not = nil
				var elem DefinitionsSchema
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Not = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"not\"")
			}
		case "items":
			if err := func() error {
				s.Items = nil
				var elem DefinitionsSchemaOrReference
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.Items = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"items\"")
			}
		case "properties":
			if err := func() error {
				s.Properties.Reset()
				if err := s.Properties.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"properties\"")
			}
		case "additionalProperties":
			if err := func() error {
				s.AdditionalProperties = nil
				var elem DefinitionsSchemaAdditionalProperties
				if err := elem.Decode(d); err != nil {
					return err
				}
				s.AdditionalProperties = &elem
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"additionalProperties\"")
			}
		case "default":
			if err := func() error {
				v, err := d.RawAppend(nil)
				s.Default = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "format":
			if err := func() error {
				s.Format.Reset()
				if err := s.Format.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"format\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsSchema")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSchema) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSchema) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsSchemaAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsSchemaAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsSchemaAdditional from json.
func (s *DefinitionsSchemaAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSchemaAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsSchemaAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSchemaAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSchemaAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsSchemaAdditionalProperties as json.
func (s DefinitionsSchemaAdditionalProperties) Encode(e *jx.Encoder) {
	switch s.Type {
	case DefinitionsSchemaOrReferenceDefinitionsSchemaAdditionalProperties:
		s.DefinitionsSchemaOrReference.Encode(e)
	case BoolDefinitionsSchemaAdditionalProperties:
		e.Bool(s.Bool)
	}
}

// Decode decodes DefinitionsSchemaAdditionalProperties from json.
func (s *DefinitionsSchemaAdditionalProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSchemaAdditionalProperties to nil")
	}
	// Sum type type_discriminator.
	switch t := d.Next(); t {
	case jx.Object:
		if err := s.DefinitionsSchemaOrReference.Decode(d); err != nil {
			return err
		}
		s.Type = DefinitionsSchemaOrReferenceDefinitionsSchemaAdditionalProperties
	case jx.Bool:
		v, err := d.Bool()
		s.Bool = bool(v)
		if err != nil {
			return err
		}
		s.Type = BoolDefinitionsSchemaAdditionalProperties
	default:
		return errors.Errorf("unexpected json type %q", t)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSchemaAdditionalProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSchemaAdditionalProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsSchemaOrReference as json.
func (s DefinitionsSchemaOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case DefinitionsSchemaDefinitionsSchemaOrReference:
		s.DefinitionsSchema.Encode(e)
	case DefinitionsReferenceDefinitionsSchemaOrReference:
		s.DefinitionsReference.Encode(e)
	}
}

// Decode decodes DefinitionsSchemaOrReference from json.
func (s *DefinitionsSchemaOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSchemaOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "nullable":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "discriminator":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "readOnly":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "writeOnly":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "xml":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "externalDocs":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "example":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "deprecated":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "title":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "multipleOf":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "maximum":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "exclusiveMaximum":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "minimum":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "exclusiveMinimum":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "maxLength":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "minLength":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "pattern":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "maxItems":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "minItems":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "uniqueItems":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "maxProperties":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "minProperties":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "required":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "enum":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "type":
				found = true
				s.Type = DefinitionsSchemaDefinitionsSchemaOrReference
			case "$ref":
				found = true
				s.Type = DefinitionsReferenceDefinitionsSchemaOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DefinitionsSchemaDefinitionsSchemaOrReference:
		if err := s.DefinitionsSchema.Decode(d); err != nil {
			return err
		}
	case DefinitionsReferenceDefinitionsSchemaOrReference:
		if err := s.DefinitionsReference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSchemaOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSchemaOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsSchemaPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsSchemaPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsSchemaPattern0 from json.
func (s *DefinitionsSchemaPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSchemaPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsSchemaPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSchemaPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSchemaPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsSchemaProperties) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsSchemaProperties) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsSchemaProperties from json.
func (s *DefinitionsSchemaProperties) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSchemaProperties to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DefinitionsSchemaOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsSchemaProperties")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSchemaProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSchemaProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsSchemaType as json.
func (s DefinitionsSchemaType) Encode(e *jx.Encoder) {
	e.Str(string(s))
}

// Decode decodes DefinitionsSchemaType from json.
func (s *DefinitionsSchemaType) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSchemaType to nil")
	}
	v, err := d.StrBytes()
	if err != nil {
		return err
	}
	// Try to use constant string.
	switch DefinitionsSchemaType(v) {
	case DefinitionsSchemaTypeArray:
		*s = DefinitionsSchemaTypeArray
	case DefinitionsSchemaTypeBoolean:
		*s = DefinitionsSchemaTypeBoolean
	case DefinitionsSchemaTypeInteger:
		*s = DefinitionsSchemaTypeInteger
	case DefinitionsSchemaTypeNull:
		*s = DefinitionsSchemaTypeNull
	case DefinitionsSchemaTypeNumber:
		*s = DefinitionsSchemaTypeNumber
	case DefinitionsSchemaTypeObject:
		*s = DefinitionsSchemaTypeObject
	case DefinitionsSchemaTypeString:
		*s = DefinitionsSchemaTypeString
	default:
		*s = DefinitionsSchemaType(v)
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSchemaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSchemaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsSchemasOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsSchemasOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsSchemasOrReferences from json.
func (s *DefinitionsSchemasOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSchemasOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DefinitionsSchemaOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsSchemasOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSchemasOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSchemasOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsSecurityRequirement) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsSecurityRequirement) encodeFields(e *jx.Encoder) {
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

var jsonFieldsNameOfDefinitionsSecurityRequirement = [0]string{}

// Decode decodes DefinitionsSecurityRequirement from json.
func (s *DefinitionsSecurityRequirement) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSecurityRequirement to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string][]string{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		default:
			var handled bool
			if pattern := regexMap["^[a-zA-Z0-9\\.\\-_]+$"]; pattern.Match(k) {
				handled = true
				var elem []string
				if err := func() error {
					elem = make([]string, 0)
					if err := d.Arr(func(d *jx.Decoder) error {
						var elemElem string
						v, err := d.Str()
						elemElem = string(v)
						if err != nil {
							return err
						}
						elem = append(elem, elemElem)
						return nil
					}); err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsSecurityRequirement")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSecurityRequirement) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSecurityRequirement) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsSecurityRequirementAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsSecurityRequirementAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsSecurityRequirementAdditional from json.
func (s *DefinitionsSecurityRequirementAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSecurityRequirementAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsSecurityRequirementAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSecurityRequirementAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSecurityRequirementAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsSecurityRequirementPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsSecurityRequirementPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.ArrStart()
		for _, elem := range elem {
			e.Str(elem)
		}
		e.ArrEnd()
	}
}

// Decode decodes DefinitionsSecurityRequirementPattern0 from json.
func (s *DefinitionsSecurityRequirementPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSecurityRequirementPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^[a-zA-Z0-9\\.\\-_]+$"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem []string
		if err := func() error {
			elem = make([]string, 0)
			if err := d.Arr(func(d *jx.Decoder) error {
				var elemElem string
				v, err := d.Str()
				elemElem = string(v)
				if err != nil {
					return err
				}
				elem = append(elem, elemElem)
				return nil
			}); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsSecurityRequirementPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSecurityRequirementPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSecurityRequirementPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsSecurityScheme) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsSecurityScheme) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("type")
		e.Str(s.Type)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.In.Set {
			e.FieldStart("in")
			s.In.Encode(e)
		}
	}
	{
		if s.Scheme.Set {
			e.FieldStart("scheme")
			s.Scheme.Encode(e)
		}
	}
	{
		if s.BearerFormat.Set {
			e.FieldStart("bearerFormat")
			s.BearerFormat.Encode(e)
		}
	}
	{
		if s.Flows.Set {
			e.FieldStart("flows")
			s.Flows.Encode(e)
		}
	}
	{
		if s.OpenIdConnectUrl.Set {
			e.FieldStart("openIdConnectUrl")
			s.OpenIdConnectUrl.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsSecurityScheme = [8]string{
	0: "type",
	1: "description",
	2: "name",
	3: "in",
	4: "scheme",
	5: "bearerFormat",
	6: "flows",
	7: "openIdConnectUrl",
}

// Decode decodes DefinitionsSecurityScheme from json.
func (s *DefinitionsSecurityScheme) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSecurityScheme to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "type":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Type = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"type\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "in":
			if err := func() error {
				s.In.Reset()
				if err := s.In.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"in\"")
			}
		case "scheme":
			if err := func() error {
				s.Scheme.Reset()
				if err := s.Scheme.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"scheme\"")
			}
		case "bearerFormat":
			if err := func() error {
				s.BearerFormat.Reset()
				if err := s.BearerFormat.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"bearerFormat\"")
			}
		case "flows":
			if err := func() error {
				s.Flows.Reset()
				if err := s.Flows.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"flows\"")
			}
		case "openIdConnectUrl":
			if err := func() error {
				s.OpenIdConnectUrl.Reset()
				if err := s.OpenIdConnectUrl.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openIdConnectUrl\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsSecurityScheme")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDefinitionsSecurityScheme) {
					name = jsonFieldsNameOfDefinitionsSecurityScheme[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSecurityScheme) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSecurityScheme) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsSecuritySchemeAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsSecuritySchemeAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsSecuritySchemeAdditional from json.
func (s *DefinitionsSecuritySchemeAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSecuritySchemeAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsSecuritySchemeAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSecuritySchemeAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSecuritySchemeAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsSecuritySchemeOrReference as json.
func (s DefinitionsSecuritySchemeOrReference) Encode(e *jx.Encoder) {
	switch s.Type {
	case DefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference:
		s.DefinitionsSecurityScheme.Encode(e)
	case DefinitionsReferenceDefinitionsSecuritySchemeOrReference:
		s.DefinitionsReference.Encode(e)
	}
}

// Decode decodes DefinitionsSecuritySchemeOrReference from json.
func (s *DefinitionsSecuritySchemeOrReference) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSecuritySchemeOrReference to nil")
	}
	// Sum type fields.
	if d.Next() != jx.Object {
		return errors.Errorf("unexpected json type %q", d.Next())
	}

	var found bool
	if err := d.Capture(func(d *jx.Decoder) error {
		return d.ObjBytes(func(d *jx.Decoder, key []byte) error {
			if found {
				return d.Skip()
			}
			switch string(key) {
			case "type":
				found = true
				s.Type = DefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference
			case "description":
				found = true
				s.Type = DefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference
			case "name":
				found = true
				s.Type = DefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference
			case "in":
				found = true
				s.Type = DefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference
			case "scheme":
				found = true
				s.Type = DefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference
			case "bearerFormat":
				found = true
				s.Type = DefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference
			case "flows":
				found = true
				s.Type = DefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference
			case "openIdConnectUrl":
				found = true
				s.Type = DefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference
			case "$ref":
				found = true
				s.Type = DefinitionsReferenceDefinitionsSecuritySchemeOrReference
			}
			return d.Skip()
		})
	}); err != nil {
		return errors.Wrap(err, "capture")
	}
	if !found {
		return errors.New("unable to detect sum type variant")
	}
	switch s.Type {
	case DefinitionsSecuritySchemeDefinitionsSecuritySchemeOrReference:
		if err := s.DefinitionsSecurityScheme.Decode(d); err != nil {
			return err
		}
	case DefinitionsReferenceDefinitionsSecuritySchemeOrReference:
		if err := s.DefinitionsReference.Decode(d); err != nil {
			return err
		}
	default:
		return errors.Errorf("inferred invalid type: %s", s.Type)
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSecuritySchemeOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSecuritySchemeOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsSecuritySchemePattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsSecuritySchemePattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsSecuritySchemePattern0 from json.
func (s *DefinitionsSecuritySchemePattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSecuritySchemePattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsSecuritySchemePattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSecuritySchemePattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSecuritySchemePattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsSecuritySchemesOrReferences) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsSecuritySchemesOrReferences) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsSecuritySchemesOrReferences from json.
func (s *DefinitionsSecuritySchemesOrReferences) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsSecuritySchemesOrReferences to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DefinitionsSecuritySchemeOrReference
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsSecuritySchemesOrReferences")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsSecuritySchemesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsSecuritySchemesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsServer) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsServer) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("url")
		e.Str(s.URL)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.Variables.Set {
			e.FieldStart("variables")
			s.Variables.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsServer = [3]string{
	0: "url",
	1: "description",
	2: "variables",
}

// Decode decodes DefinitionsServer from json.
func (s *DefinitionsServer) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsServer to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "url":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.URL = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"url\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "variables":
			if err := func() error {
				s.Variables.Reset()
				if err := s.Variables.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"variables\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsServer")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDefinitionsServer) {
					name = jsonFieldsNameOfDefinitionsServer[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsServer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsServer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsServerAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsServerAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsServerAdditional from json.
func (s *DefinitionsServerAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsServerAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsServerAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsServerAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsServerAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsServerPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsServerPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsServerPattern0 from json.
func (s *DefinitionsServerPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsServerPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsServerPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsServerPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsServerPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsServerVariable) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsServerVariable) encodeFields(e *jx.Encoder) {
	{
		if s.Enum != nil {
			e.FieldStart("enum")
			e.ArrStart()
			for _, elem := range s.Enum {
				e.Str(elem)
			}
			e.ArrEnd()
		}
	}
	{

		e.FieldStart("default")
		e.Str(s.Default)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsServerVariable = [3]string{
	0: "enum",
	1: "default",
	2: "description",
}

// Decode decodes DefinitionsServerVariable from json.
func (s *DefinitionsServerVariable) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsServerVariable to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "enum":
			if err := func() error {
				s.Enum = make([]string, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem string
					v, err := d.Str()
					elem = string(v)
					if err != nil {
						return err
					}
					s.Enum = append(s.Enum, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"enum\"")
			}
		case "default":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				v, err := d.Str()
				s.Default = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"default\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsServerVariable")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000010,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDefinitionsServerVariable) {
					name = jsonFieldsNameOfDefinitionsServerVariable[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsServerVariable) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsServerVariable) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsServerVariableAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsServerVariableAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsServerVariableAdditional from json.
func (s *DefinitionsServerVariableAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsServerVariableAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsServerVariableAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsServerVariableAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsServerVariableAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsServerVariablePattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsServerVariablePattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsServerVariablePattern0 from json.
func (s *DefinitionsServerVariablePattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsServerVariablePattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsServerVariablePattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsServerVariablePattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsServerVariablePattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsServerVariables) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsServerVariables) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		elem.Encode(e)
	}
}

// Decode decodes DefinitionsServerVariables from json.
func (s *DefinitionsServerVariables) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsServerVariables to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem DefinitionsServerVariable
		if err := func() error {
			if err := elem.Decode(d); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsServerVariables")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsServerVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsServerVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsStringArray as json.
func (s DefinitionsStringArray) Encode(e *jx.Encoder) {
	unwrapped := []string(s)
	e.ArrStart()
	for _, elem := range unwrapped {
		e.Str(elem)
	}
	e.ArrEnd()
}

// Decode decodes DefinitionsStringArray from json.
func (s *DefinitionsStringArray) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsStringArray to nil")
	}
	var unwrapped []string
	if err := func() error {
		unwrapped = make([]string, 0)
		if err := d.Arr(func(d *jx.Decoder) error {
			var elem string
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			unwrapped = append(unwrapped, elem)
			return nil
		}); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		return errors.Wrap(err, "alias")
	}
	*s = DefinitionsStringArray(unwrapped)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsStringArray) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsStringArray) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsStrings) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsStrings) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		e.Str(elem)
	}
}

// Decode decodes DefinitionsStrings from json.
func (s *DefinitionsStrings) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsStrings to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem string
		if err := func() error {
			v, err := d.Str()
			elem = string(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsStrings")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsStrings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsStrings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsTag) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsTag) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("name")
		e.Str(s.Name)
	}
	{
		if s.Description.Set {
			e.FieldStart("description")
			s.Description.Encode(e)
		}
	}
	{
		if s.ExternalDocs.Set {
			e.FieldStart("externalDocs")
			s.ExternalDocs.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsTag = [3]string{
	0: "name",
	1: "description",
	2: "externalDocs",
}

// Decode decodes DefinitionsTag from json.
func (s *DefinitionsTag) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsTag to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Name = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "description":
			if err := func() error {
				s.Description.Reset()
				if err := s.Description.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"description\"")
			}
		case "externalDocs":
			if err := func() error {
				s.ExternalDocs.Reset()
				if err := s.ExternalDocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalDocs\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsTag")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00000001,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfDefinitionsTag) {
					name = jsonFieldsNameOfDefinitionsTag[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsTag) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsTag) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsTagAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsTagAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsTagAdditional from json.
func (s *DefinitionsTagAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsTagAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsTagAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsTagAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsTagAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsTagPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsTagPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsTagPattern0 from json.
func (s *DefinitionsTagPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsTagPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsTagPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsTagPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsTagPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsXML) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s DefinitionsXML) encodeFields(e *jx.Encoder) {
	{
		if s.Name.Set {
			e.FieldStart("name")
			s.Name.Encode(e)
		}
	}
	{
		if s.Namespace.Set {
			e.FieldStart("namespace")
			s.Namespace.Encode(e)
		}
	}
	{
		if s.Prefix.Set {
			e.FieldStart("prefix")
			s.Prefix.Encode(e)
		}
	}
	{
		if s.Attribute.Set {
			e.FieldStart("attribute")
			s.Attribute.Encode(e)
		}
	}
	{
		if s.Wrapped.Set {
			e.FieldStart("wrapped")
			s.Wrapped.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfDefinitionsXML = [5]string{
	0: "name",
	1: "namespace",
	2: "prefix",
	3: "attribute",
	4: "wrapped",
}

// Decode decodes DefinitionsXML from json.
func (s *DefinitionsXML) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsXML to nil")
	}
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "name":
			if err := func() error {
				s.Name.Reset()
				if err := s.Name.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"name\"")
			}
		case "namespace":
			if err := func() error {
				s.Namespace.Reset()
				if err := s.Namespace.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"namespace\"")
			}
		case "prefix":
			if err := func() error {
				s.Prefix.Reset()
				if err := s.Prefix.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"prefix\"")
			}
		case "attribute":
			if err := func() error {
				s.Attribute.Reset()
				if err := s.Attribute.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"attribute\"")
			}
		case "wrapped":
			if err := func() error {
				s.Wrapped.Reset()
				if err := s.Wrapped.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"wrapped\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsXML")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsXML) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsXML) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsXMLAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsXMLAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsXMLAdditional from json.
func (s *DefinitionsXMLAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsXMLAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsXMLAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsXMLAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsXMLAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s DefinitionsXMLPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s DefinitionsXMLPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes DefinitionsXMLPattern0 from json.
func (s *DefinitionsXMLPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode DefinitionsXMLPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode DefinitionsXMLPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s DefinitionsXMLPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *DefinitionsXMLPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes bool as json.
func (o OptBool) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Bool(bool(o.Value))
}

// Decode decodes bool from json.
func (o *OptBool) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptBool to nil")
	}
	o.Set = true
	v, err := d.Bool()
	if err != nil {
		return err
	}
	o.Value = bool(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptBool) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptBool) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsAnysOrExpressions as json.
func (o OptDefinitionsAnysOrExpressions) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsAnysOrExpressions from json.
func (o *OptDefinitionsAnysOrExpressions) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsAnysOrExpressions to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsAnysOrExpressions)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsAnysOrExpressions) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsAnysOrExpressions) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsCallbacksOrReferences as json.
func (o OptDefinitionsCallbacksOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsCallbacksOrReferences from json.
func (o *OptDefinitionsCallbacksOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsCallbacksOrReferences to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsCallbacksOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsCallbacksOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsCallbacksOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsComponents as json.
func (o OptDefinitionsComponents) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsComponents from json.
func (o *OptDefinitionsComponents) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsComponents to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsComponents) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsComponents) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsContact as json.
func (o OptDefinitionsContact) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsContact from json.
func (o *OptDefinitionsContact) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsContact to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsContact) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsContact) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsDiscriminator as json.
func (o OptDefinitionsDiscriminator) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsDiscriminator from json.
func (o *OptDefinitionsDiscriminator) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsDiscriminator to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsDiscriminator) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsDiscriminator) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsEncodings as json.
func (o OptDefinitionsEncodings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsEncodings from json.
func (o *OptDefinitionsEncodings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsEncodings to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsEncodings)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsEncodings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsEncodings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsExamplesOrReferences as json.
func (o OptDefinitionsExamplesOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsExamplesOrReferences from json.
func (o *OptDefinitionsExamplesOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsExamplesOrReferences to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsExamplesOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsExamplesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsExamplesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsExternalDocs as json.
func (o OptDefinitionsExternalDocs) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsExternalDocs from json.
func (o *OptDefinitionsExternalDocs) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsExternalDocs to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsExternalDocs) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsExternalDocs) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsHeadersOrReferences as json.
func (o OptDefinitionsHeadersOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsHeadersOrReferences from json.
func (o *OptDefinitionsHeadersOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsHeadersOrReferences to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsHeadersOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsHeadersOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsHeadersOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum as json.
func (o OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesExclusiveMaximum from json.
func (o *OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsJsonschemaDraft4PropertiesExclusiveMaximum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum as json.
func (o OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesExclusiveMinimum from json.
func (o *OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsJsonschemaDraft4PropertiesExclusiveMinimum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesMaximum as json.
func (o OptDefinitionsJsonschemaDraft4PropertiesMaximum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesMaximum from json.
func (o *OptDefinitionsJsonschemaDraft4PropertiesMaximum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsJsonschemaDraft4PropertiesMaximum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsJsonschemaDraft4PropertiesMaximum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsJsonschemaDraft4PropertiesMaximum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesMinimum as json.
func (o OptDefinitionsJsonschemaDraft4PropertiesMinimum) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesMinimum from json.
func (o *OptDefinitionsJsonschemaDraft4PropertiesMinimum) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsJsonschemaDraft4PropertiesMinimum to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsJsonschemaDraft4PropertiesMinimum) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsJsonschemaDraft4PropertiesMinimum) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesMultipleOf as json.
func (o OptDefinitionsJsonschemaDraft4PropertiesMultipleOf) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesMultipleOf from json.
func (o *OptDefinitionsJsonschemaDraft4PropertiesMultipleOf) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsJsonschemaDraft4PropertiesMultipleOf to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsJsonschemaDraft4PropertiesMultipleOf) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsJsonschemaDraft4PropertiesMultipleOf) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesPattern as json.
func (o OptDefinitionsJsonschemaDraft4PropertiesPattern) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesPattern from json.
func (o *OptDefinitionsJsonschemaDraft4PropertiesPattern) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsJsonschemaDraft4PropertiesPattern to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsJsonschemaDraft4PropertiesPattern) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsJsonschemaDraft4PropertiesPattern) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesTitle as json.
func (o OptDefinitionsJsonschemaDraft4PropertiesTitle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesTitle from json.
func (o *OptDefinitionsJsonschemaDraft4PropertiesTitle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsJsonschemaDraft4PropertiesTitle to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsJsonschemaDraft4PropertiesTitle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsJsonschemaDraft4PropertiesTitle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsJsonschemaDraft4PropertiesUniqueItems as json.
func (o OptDefinitionsJsonschemaDraft4PropertiesUniqueItems) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsJsonschemaDraft4PropertiesUniqueItems from json.
func (o *OptDefinitionsJsonschemaDraft4PropertiesUniqueItems) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsJsonschemaDraft4PropertiesUniqueItems to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsJsonschemaDraft4PropertiesUniqueItems) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsJsonschemaDraft4PropertiesUniqueItems) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsLicense as json.
func (o OptDefinitionsLicense) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsLicense from json.
func (o *OptDefinitionsLicense) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsLicense to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsLicense) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsLicense) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsLinksOrReferences as json.
func (o OptDefinitionsLinksOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsLinksOrReferences from json.
func (o *OptDefinitionsLinksOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsLinksOrReferences to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsLinksOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsLinksOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsLinksOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsMediaTypes as json.
func (o OptDefinitionsMediaTypes) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsMediaTypes from json.
func (o *OptDefinitionsMediaTypes) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsMediaTypes to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsMediaTypes)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsMediaTypes) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsMediaTypes) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsOauthFlow as json.
func (o OptDefinitionsOauthFlow) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsOauthFlow from json.
func (o *OptDefinitionsOauthFlow) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsOauthFlow to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsOauthFlow) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsOauthFlow) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsOauthFlows as json.
func (o OptDefinitionsOauthFlows) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsOauthFlows from json.
func (o *OptDefinitionsOauthFlows) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsOauthFlows to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsOauthFlows) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsOauthFlows) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsOperation as json.
func (o OptDefinitionsOperation) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsOperation from json.
func (o *OptDefinitionsOperation) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsOperation to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsOperation) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsOperation) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsParameterStyle as json.
func (o OptDefinitionsParameterStyle) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DefinitionsParameterStyle from json.
func (o *OptDefinitionsParameterStyle) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsParameterStyle to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsParameterStyle) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsParameterStyle) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsParametersOrReferences as json.
func (o OptDefinitionsParametersOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsParametersOrReferences from json.
func (o *OptDefinitionsParametersOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsParametersOrReferences to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsParametersOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsParametersOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsParametersOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsPositiveInteger as json.
func (o OptDefinitionsPositiveInteger) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsPositiveInteger from json.
func (o *OptDefinitionsPositiveInteger) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsPositiveInteger to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsPositiveInteger) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsPositiveInteger) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsRequestBodiesOrReferences as json.
func (o OptDefinitionsRequestBodiesOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsRequestBodiesOrReferences from json.
func (o *OptDefinitionsRequestBodiesOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsRequestBodiesOrReferences to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsRequestBodiesOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsRequestBodiesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsRequestBodiesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsRequestBodyOrReference as json.
func (o OptDefinitionsRequestBodyOrReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsRequestBodyOrReference from json.
func (o *OptDefinitionsRequestBodyOrReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsRequestBodyOrReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsRequestBodyOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsRequestBodyOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsResponseOrReference as json.
func (o OptDefinitionsResponseOrReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsResponseOrReference from json.
func (o *OptDefinitionsResponseOrReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsResponseOrReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsResponseOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsResponseOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsResponsesOrReferences as json.
func (o OptDefinitionsResponsesOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsResponsesOrReferences from json.
func (o *OptDefinitionsResponsesOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsResponsesOrReferences to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsResponsesOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsResponsesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsResponsesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsSchemaOrReference as json.
func (o OptDefinitionsSchemaOrReference) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsSchemaOrReference from json.
func (o *OptDefinitionsSchemaOrReference) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsSchemaOrReference to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsSchemaOrReference) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsSchemaOrReference) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsSchemaProperties as json.
func (o OptDefinitionsSchemaProperties) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsSchemaProperties from json.
func (o *OptDefinitionsSchemaProperties) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsSchemaProperties to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsSchemaProperties)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsSchemaProperties) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsSchemaProperties) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsSchemaType as json.
func (o OptDefinitionsSchemaType) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes DefinitionsSchemaType from json.
func (o *OptDefinitionsSchemaType) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsSchemaType to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsSchemaType) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsSchemaType) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsSchemasOrReferences as json.
func (o OptDefinitionsSchemasOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsSchemasOrReferences from json.
func (o *OptDefinitionsSchemasOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsSchemasOrReferences to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsSchemasOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsSchemasOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsSchemasOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsSecuritySchemesOrReferences as json.
func (o OptDefinitionsSecuritySchemesOrReferences) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsSecuritySchemesOrReferences from json.
func (o *OptDefinitionsSecuritySchemesOrReferences) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsSecuritySchemesOrReferences to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsSecuritySchemesOrReferences)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsSecuritySchemesOrReferences) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsSecuritySchemesOrReferences) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsServer as json.
func (o OptDefinitionsServer) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsServer from json.
func (o *OptDefinitionsServer) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsServer to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsServer) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsServer) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsServerVariables as json.
func (o OptDefinitionsServerVariables) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsServerVariables from json.
func (o *OptDefinitionsServerVariables) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsServerVariables to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsServerVariables)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsServerVariables) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsServerVariables) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsStrings as json.
func (o OptDefinitionsStrings) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsStrings from json.
func (o *OptDefinitionsStrings) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsStrings to nil")
	}
	o.Set = true
	o.Value = make(DefinitionsStrings)
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsStrings) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsStrings) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes DefinitionsXML as json.
func (o OptDefinitionsXML) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	o.Value.Encode(e)
}

// Decode decodes DefinitionsXML from json.
func (o *OptDefinitionsXML) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptDefinitionsXML to nil")
	}
	o.Set = true
	if err := o.Value.Decode(d); err != nil {
		return err
	}
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptDefinitionsXML) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptDefinitionsXML) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode encodes string as json.
func (o OptString) Encode(e *jx.Encoder) {
	if !o.Set {
		return
	}
	e.Str(string(o.Value))
}

// Decode decodes string from json.
func (o *OptString) Decode(d *jx.Decoder) error {
	if o == nil {
		return errors.New("invalid: unable to decode OptString to nil")
	}
	o.Set = true
	v, err := d.Str()
	if err != nil {
		return err
	}
	o.Value = string(v)
	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s OptString) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *OptString) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s Spec) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields encodes fields.
func (s Spec) encodeFields(e *jx.Encoder) {
	{

		e.FieldStart("openapi")
		e.Str(s.Openapi)
	}
	{

		e.FieldStart("info")
		s.Info.Encode(e)
	}
	{
		if s.Servers != nil {
			e.FieldStart("servers")
			e.ArrStart()
			for _, elem := range s.Servers {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{

		e.FieldStart("paths")
		s.Paths.Encode(e)
	}
	{
		if s.Components.Set {
			e.FieldStart("components")
			s.Components.Encode(e)
		}
	}
	{
		if s.Security != nil {
			e.FieldStart("security")
			e.ArrStart()
			for _, elem := range s.Security {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.Tags != nil {
			e.FieldStart("tags")
			e.ArrStart()
			for _, elem := range s.Tags {
				elem.Encode(e)
			}
			e.ArrEnd()
		}
	}
	{
		if s.ExternalDocs.Set {
			e.FieldStart("externalDocs")
			s.ExternalDocs.Encode(e)
		}
	}
	for k, elem := range s.AdditionalProps {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
	for k, elem := range s.Pattern0Props {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

var jsonFieldsNameOfSpec = [8]string{
	0: "openapi",
	1: "info",
	2: "servers",
	3: "paths",
	4: "components",
	5: "security",
	6: "tags",
	7: "externalDocs",
}

// Decode decodes Spec from json.
func (s *Spec) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode Spec to nil")
	}
	var requiredBitSet [1]uint8
	s.AdditionalProps = map[string]jx.Raw{}
	s.Pattern0Props = map[string]jx.Raw{}

	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		switch string(k) {
		case "openapi":
			requiredBitSet[0] |= 1 << 0
			if err := func() error {
				v, err := d.Str()
				s.Openapi = string(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"openapi\"")
			}
		case "info":
			requiredBitSet[0] |= 1 << 1
			if err := func() error {
				if err := s.Info.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"info\"")
			}
		case "servers":
			if err := func() error {
				s.Servers = make([]DefinitionsServer, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DefinitionsServer
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Servers = append(s.Servers, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"servers\"")
			}
		case "paths":
			requiredBitSet[0] |= 1 << 3
			if err := func() error {
				if err := s.Paths.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"paths\"")
			}
		case "components":
			if err := func() error {
				s.Components.Reset()
				if err := s.Components.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"components\"")
			}
		case "security":
			if err := func() error {
				s.Security = make([]DefinitionsSecurityRequirement, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DefinitionsSecurityRequirement
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Security = append(s.Security, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"security\"")
			}
		case "tags":
			if err := func() error {
				s.Tags = make([]DefinitionsTag, 0)
				if err := d.Arr(func(d *jx.Decoder) error {
					var elem DefinitionsTag
					if err := elem.Decode(d); err != nil {
						return err
					}
					s.Tags = append(s.Tags, elem)
					return nil
				}); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"tags\"")
			}
		case "externalDocs":
			if err := func() error {
				s.ExternalDocs.Reset()
				if err := s.ExternalDocs.Decode(d); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrap(err, "decode field \"externalDocs\"")
			}
		default:
			var handled bool
			if pattern := regexMap["^x-"]; pattern.Match(k) {
				handled = true
				var elem jx.Raw
				if err := func() error {
					v, err := d.RawAppend(nil)
					elem = jx.Raw(v)
					if err != nil {
						return err
					}
					return nil
				}(); err != nil {
					return errors.Wrapf(err, "decode field %q", k)
				}
				s.Pattern0Props[string(k)] = elem
			}
			if handled {
				return nil
			}
			var elem jx.Raw
			if err := func() error {
				v, err := d.RawAppend(nil)
				elem = jx.Raw(v)
				if err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return errors.Wrapf(err, "decode field %q", k)
			}
			s.AdditionalProps[string(k)] = elem
		}
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode Spec")
	}
	// Validate required fields.
	var failures []validate.FieldError
	for i, mask := range [1]uint8{
		0b00001011,
	} {
		if result := (requiredBitSet[i] & mask) ^ mask; result != 0 {
			// Mask only required fields and check equality to mask using XOR.
			//
			// If XOR result is not zero, result is not equal to expected, so some fields are missed.
			// Bits of fields which would be set are actually bits of missed fields.
			missed := bits.OnesCount8(result)
			for bitN := 0; bitN < missed; bitN++ {
				bitIdx := bits.TrailingZeros8(result)
				fieldIdx := i*8 + bitIdx
				var name string
				if fieldIdx < len(jsonFieldsNameOfSpec) {
					name = jsonFieldsNameOfSpec[fieldIdx]
				} else {
					name = strconv.Itoa(fieldIdx)
				}
				failures = append(failures, validate.FieldError{
					Name:  name,
					Error: validate.ErrFieldRequired,
				})
				// Reset bit.
				result &^= 1 << bitIdx
			}
		}
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s Spec) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *Spec) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpecAdditional) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpecAdditional) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SpecAdditional from json.
func (s *SpecAdditional) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpecAdditional to nil")
	}
	m := s.init()
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpecAdditional")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpecAdditional) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpecAdditional) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

// Encode implements json.Marshaler.
func (s SpecPattern0) Encode(e *jx.Encoder) {
	e.ObjStart()
	s.encodeFields(e)
	e.ObjEnd()
}

// encodeFields implements json.Marshaler.
func (s SpecPattern0) encodeFields(e *jx.Encoder) {
	for k, elem := range s {
		e.FieldStart(k)

		if len(elem) != 0 {
			e.Raw(elem)
		}
	}
}

// Decode decodes SpecPattern0 from json.
func (s *SpecPattern0) Decode(d *jx.Decoder) error {
	if s == nil {
		return errors.New("invalid: unable to decode SpecPattern0 to nil")
	}
	m := s.init()
	pattern := regexMap["^x-"]
	if err := d.ObjBytes(func(d *jx.Decoder, k []byte) error {
		if !pattern.Match(k) {
			return d.Skip()
		}
		var elem jx.Raw
		if err := func() error {
			v, err := d.RawAppend(nil)
			elem = jx.Raw(v)
			if err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrapf(err, "decode field %q", k)
		}
		m[string(k)] = elem
		return nil
	}); err != nil {
		return errors.Wrap(err, "decode SpecPattern0")
	}

	return nil
}

// MarshalJSON implements stdjson.Marshaler.
func (s SpecPattern0) MarshalJSON() ([]byte, error) {
	e := jx.Encoder{}
	s.Encode(&e)
	return e.Bytes(), nil
}

// UnmarshalJSON implements stdjson.Unmarshaler.
func (s *SpecPattern0) UnmarshalJSON(data []byte) error {
	d := jx.DecodeBytes(data)
	return s.Decode(d)
}

func (s DefinitionsCallback) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Pattern0Props.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "Pattern0Props",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsCallbackOrReference) Validate() error {
	switch s.Type {
	case DefinitionsCallbackDefinitionsCallbackOrReference:
		if err := s.DefinitionsCallback.Validate(); err != nil {
			return err
		}
		return nil
	case DefinitionsReferenceDefinitionsCallbackOrReference:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DefinitionsCallbackPattern0) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsCallbacksOrReferences) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsComponents) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Schemas.Set {
			if err := func() error {
				if err := s.Schemas.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "schemas",
			Error: err,
		})
	}
	if err := func() error {
		if s.Responses.Set {
			if err := func() error {
				if err := s.Responses.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "responses",
			Error: err,
		})
	}
	if err := func() error {
		if s.Parameters.Set {
			if err := func() error {
				if err := s.Parameters.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "parameters",
			Error: err,
		})
	}
	if err := func() error {
		if s.RequestBodies.Set {
			if err := func() error {
				if err := s.RequestBodies.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "requestBodies",
			Error: err,
		})
	}
	if err := func() error {
		if s.Headers.Set {
			if err := func() error {
				if err := s.Headers.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "headers",
			Error: err,
		})
	}
	if err := func() error {
		if s.Callbacks.Set {
			if err := func() error {
				if err := s.Callbacks.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "callbacks",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsEncoding) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Headers.Set {
			if err := func() error {
				if err := s.Headers.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "headers",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsEncodings) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsHeader) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Schema.Set {
			if err := func() error {
				if err := s.Schema.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "schema",
			Error: err,
		})
	}
	if err := func() error {
		if s.Content.Set {
			if err := func() error {
				if err := s.Content.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "content",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsHeaderOrReference) Validate() error {
	switch s.Type {
	case DefinitionsHeaderDefinitionsHeaderOrReference:
		if err := s.DefinitionsHeader.Validate(); err != nil {
			return err
		}
		return nil
	case DefinitionsReferenceDefinitionsHeaderOrReference:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DefinitionsHeadersOrReferences) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsJsonschemaDraft4PropertiesEnum) Validate() error {
	if s == nil {
		return errors.New("nil is invalid value")
	}
	if err := (validate.Array{
		MinLength:    1,
		MinLengthSet: true,
		MaxLength:    0,
		MaxLengthSet: false,
	}).ValidateLength(len(s)); err != nil {
		return errors.Wrap(err, "array")
	}
	return nil
}
func (s DefinitionsJsonschemaDraft4PropertiesMaximum) Validate() error {
	if err := (validate.Float{}).Validate(float64(s)); err != nil {
		return errors.Wrap(err, "float")
	}
	return nil
}
func (s DefinitionsJsonschemaDraft4PropertiesMinimum) Validate() error {
	if err := (validate.Float{}).Validate(float64(s)); err != nil {
		return errors.Wrap(err, "float")
	}
	return nil
}
func (s DefinitionsJsonschemaDraft4PropertiesMultipleOf) Validate() error {
	if err := (validate.Float{
		MinSet:        true,
		Min:           0,
		MaxSet:        false,
		Max:           0,
		MinExclusive:  true,
		MaxExclusive:  false,
		MultipleOfSet: false,
		MultipleOf:    nil,
	}).Validate(float64(s)); err != nil {
		return errors.Wrap(err, "float")
	}
	return nil
}
func (s DefinitionsMediaType) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Schema.Set {
			if err := func() error {
				if err := s.Schema.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "schema",
			Error: err,
		})
	}
	if err := func() error {
		if s.Encoding.Set {
			if err := func() error {
				if err := s.Encoding.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "encoding",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsMediaTypes) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsOperation) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Parameters {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "parameters",
			Error: err,
		})
	}
	if err := func() error {
		if s.RequestBody.Set {
			if err := func() error {
				if err := s.RequestBody.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "requestBody",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Responses.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "responses",
			Error: err,
		})
	}
	if err := func() error {
		if s.Callbacks.Set {
			if err := func() error {
				if err := s.Callbacks.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "callbacks",
			Error: err,
		})
	}
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Security {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "security",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsParameter) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.In.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "in",
			Error: err,
		})
	}
	if err := func() error {
		if s.Style.Set {
			if err := func() error {
				if err := s.Style.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "style",
			Error: err,
		})
	}
	if err := func() error {
		if s.Schema.Set {
			if err := func() error {
				if err := s.Schema.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "schema",
			Error: err,
		})
	}
	if err := func() error {
		if s.Content.Set {
			if err := func() error {
				if err := s.Content.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "content",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsParameterIn) Validate() error {
	switch s {
	case "path":
		return nil
	case "query":
		return nil
	case "cookie":
		return nil
	case "header":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s DefinitionsParameterOrReference) Validate() error {
	switch s.Type {
	case DefinitionsParameterDefinitionsParameterOrReference:
		if err := s.DefinitionsParameter.Validate(); err != nil {
			return err
		}
		return nil
	case DefinitionsReferenceDefinitionsParameterOrReference:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DefinitionsParameterStyle) Validate() error {
	switch s {
	case "matrix":
		return nil
	case "label":
		return nil
	case "form":
		return nil
	case "simple":
		return nil
	case "spaceDelimited":
		return nil
	case "pipeDelimited":
		return nil
	case "deepObject":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s DefinitionsParametersOrReferences) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsPathItem) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Get.Set {
			if err := func() error {
				if err := s.Get.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "get",
			Error: err,
		})
	}
	if err := func() error {
		if s.Put.Set {
			if err := func() error {
				if err := s.Put.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "put",
			Error: err,
		})
	}
	if err := func() error {
		if s.Post.Set {
			if err := func() error {
				if err := s.Post.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "post",
			Error: err,
		})
	}
	if err := func() error {
		if s.Delete.Set {
			if err := func() error {
				if err := s.Delete.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "delete",
			Error: err,
		})
	}
	if err := func() error {
		if s.Options.Set {
			if err := func() error {
				if err := s.Options.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "options",
			Error: err,
		})
	}
	if err := func() error {
		if s.Head.Set {
			if err := func() error {
				if err := s.Head.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "head",
			Error: err,
		})
	}
	if err := func() error {
		if s.Patch.Set {
			if err := func() error {
				if err := s.Patch.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "patch",
			Error: err,
		})
	}
	if err := func() error {
		if s.Trace.Set {
			if err := func() error {
				if err := s.Trace.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "trace",
			Error: err,
		})
	}
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Parameters {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "parameters",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsPaths) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Pattern0Props.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "Pattern0Props",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsPathsPattern0) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsPositiveInteger) Validate() error {
	if err := (validate.Int{
		MinSet:        true,
		Min:           0,
		MaxSet:        false,
		Max:           0,
		MinExclusive:  false,
		MaxExclusive:  false,
		MultipleOfSet: false,
		MultipleOf:    0,
	}).Validate(int64(s)); err != nil {
		return errors.Wrap(err, "int")
	}
	return nil
}
func (s DefinitionsRequestBodiesOrReferences) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsRequestBody) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Content.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "content",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsRequestBodyOrReference) Validate() error {
	switch s.Type {
	case DefinitionsRequestBodyDefinitionsRequestBodyOrReference:
		if err := s.DefinitionsRequestBody.Validate(); err != nil {
			return err
		}
		return nil
	case DefinitionsReferenceDefinitionsRequestBodyOrReference:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DefinitionsResponse) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Headers.Set {
			if err := func() error {
				if err := s.Headers.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "headers",
			Error: err,
		})
	}
	if err := func() error {
		if s.Content.Set {
			if err := func() error {
				if err := s.Content.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "content",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsResponseOrReference) Validate() error {
	switch s.Type {
	case DefinitionsResponseDefinitionsResponseOrReference:
		if err := s.DefinitionsResponse.Validate(); err != nil {
			return err
		}
		return nil
	case DefinitionsReferenceDefinitionsResponseOrReference:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DefinitionsResponses) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.Default.Set {
			if err := func() error {
				if err := s.Default.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "default",
			Error: err,
		})
	}
	if err := func() error {
		if err := s.Pattern0Props.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "Pattern0Props",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsResponsesOrReferences) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsResponsesPattern0) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsSchema) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if s.MultipleOf.Set {
			if err := func() error {
				if err := s.MultipleOf.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "multipleOf",
			Error: err,
		})
	}
	if err := func() error {
		if s.Maximum.Set {
			if err := func() error {
				if err := s.Maximum.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "maximum",
			Error: err,
		})
	}
	if err := func() error {
		if s.Minimum.Set {
			if err := func() error {
				if err := s.Minimum.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "minimum",
			Error: err,
		})
	}
	if err := func() error {
		if s.MaxLength.Set {
			if err := func() error {
				if err := s.MaxLength.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "maxLength",
			Error: err,
		})
	}
	if err := func() error {
		if s.MinLength.Set {
			if err := func() error {
				if err := s.MinLength.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "minLength",
			Error: err,
		})
	}
	if err := func() error {
		if s.MaxItems.Set {
			if err := func() error {
				if err := s.MaxItems.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "maxItems",
			Error: err,
		})
	}
	if err := func() error {
		if s.MinItems.Set {
			if err := func() error {
				if err := s.MinItems.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "minItems",
			Error: err,
		})
	}
	if err := func() error {
		if s.MaxProperties.Set {
			if err := func() error {
				if err := s.MaxProperties.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "maxProperties",
			Error: err,
		})
	}
	if err := func() error {
		if s.MinProperties.Set {
			if err := func() error {
				if err := s.MinProperties.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "minProperties",
			Error: err,
		})
	}
	if err := func() error {
		if s.Required == nil {
			return nil // optional
		}
		if err := func() error {
			if err := s.Required.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrap(err, "pointer")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "required",
			Error: err,
		})
	}
	if err := func() error {
		if s.Enum == nil {
			return nil // optional
		}
		if err := func() error {
			if err := s.Enum.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrap(err, "pointer")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "enum",
			Error: err,
		})
	}
	if err := func() error {
		if s.Type.Set {
			if err := func() error {
				if err := s.Type.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "type",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Array{
			MinLength:    1,
			MinLengthSet: true,
			MaxLength:    0,
			MaxLengthSet: false,
		}).ValidateLength(len(s.AllOf)); err != nil {
			return errors.Wrap(err, "array")
		}
		var failures []validate.FieldError
		for i, elem := range s.AllOf {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "allOf",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Array{
			MinLength:    1,
			MinLengthSet: true,
			MaxLength:    0,
			MaxLengthSet: false,
		}).ValidateLength(len(s.OneOf)); err != nil {
			return errors.Wrap(err, "array")
		}
		var failures []validate.FieldError
		for i, elem := range s.OneOf {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "oneOf",
			Error: err,
		})
	}
	if err := func() error {
		if err := (validate.Array{
			MinLength:    1,
			MinLengthSet: true,
			MaxLength:    0,
			MaxLengthSet: false,
		}).ValidateLength(len(s.AnyOf)); err != nil {
			return errors.Wrap(err, "array")
		}
		var failures []validate.FieldError
		for i, elem := range s.AnyOf {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "anyOf",
			Error: err,
		})
	}
	if err := func() error {
		if s.Not == nil {
			return nil // optional
		}
		if err := func() error {
			if err := s.Not.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrap(err, "pointer")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "not",
			Error: err,
		})
	}
	if err := func() error {
		if s.Items == nil {
			return nil // optional
		}
		if err := func() error {
			if err := s.Items.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrap(err, "pointer")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "items",
			Error: err,
		})
	}
	if err := func() error {
		if s.Properties.Set {
			if err := func() error {
				if err := s.Properties.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "properties",
			Error: err,
		})
	}
	if err := func() error {
		if s.AdditionalProperties == nil {
			return nil // optional
		}
		if err := func() error {
			if err := s.AdditionalProperties.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			return errors.Wrap(err, "pointer")
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "additionalProperties",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsSchemaAdditionalProperties) Validate() error {
	switch s.Type {
	case DefinitionsSchemaOrReferenceDefinitionsSchemaAdditionalProperties:
		if err := s.DefinitionsSchemaOrReference.Validate(); err != nil {
			return err
		}
		return nil
	case BoolDefinitionsSchemaAdditionalProperties:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DefinitionsSchemaOrReference) Validate() error {
	switch s.Type {
	case DefinitionsSchemaDefinitionsSchemaOrReference:
		if err := s.DefinitionsSchema.Validate(); err != nil {
			return err
		}
		return nil
	case DefinitionsReferenceDefinitionsSchemaOrReference:
		return nil // no validation needed
	default:
		return errors.Errorf("invalid type %q", s.Type)
	}
}

func (s DefinitionsSchemaProperties) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsSchemaType) Validate() error {
	switch s {
	case "array":
		return nil
	case "boolean":
		return nil
	case "integer":
		return nil
	case "null":
		return nil
	case "number":
		return nil
	case "object":
		return nil
	case "string":
		return nil
	default:
		return errors.Errorf("invalid value: %v", s)
	}
}
func (s DefinitionsSchemasOrReferences) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if err := elem.Validate(); err != nil {
				return err
			}
			return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsSecurityRequirement) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Pattern0Props.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "Pattern0Props",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsSecurityRequirementPattern0) Validate() error {
	var failures []validate.FieldError
	for key, elem := range s {
		if err := func() error {
			if elem == nil {
				return errors.New("nil is invalid value")
			}
			return nil
		}(); err != nil {
			failures = append(failures, validate.FieldError{
				Name:  key,
				Error: err,
			})
		}
	}

	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
func (s DefinitionsStringArray) Validate() error {
	if s == nil {
		return errors.New("nil is invalid value")
	}
	if err := (validate.Array{
		MinLength:    1,
		MinLengthSet: true,
		MaxLength:    0,
		MaxLengthSet: false,
	}).ValidateLength(len(s)); err != nil {
		return errors.Wrap(err, "array")
	}
	return nil
}

func (s Spec) Validate() error {
	var failures []validate.FieldError
	if err := func() error {
		if err := s.Paths.Validate(); err != nil {
			return err
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "paths",
			Error: err,
		})
	}
	if err := func() error {
		if s.Components.Set {
			if err := func() error {
				if err := s.Components.Value.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return err
			}
		}
		return nil
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "components",
			Error: err,
		})
	}
	if err := func() error {
		var failures []validate.FieldError
		for i, elem := range s.Security {
			if err := func() error {
				if err := elem.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				failures = append(failures, validate.FieldError{
					Name:  fmt.Sprintf("[%d]", i),
					Error: err,
				})
			}
		}
		if len(failures) > 0 {
			return &validate.Error{Fields: failures}
		}
		return nil
	}(); err != nil {
		failures = append(failures, validate.FieldError{
			Name:  "security",
			Error: err,
		})
	}
	if len(failures) > 0 {
		return &validate.Error{Fields: failures}
	}
	return nil
}
