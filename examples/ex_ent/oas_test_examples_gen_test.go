// Code generated by ogen, DO NOT EDIT.

package api

import (
	"github.com/go-faster/jx"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestCreatePetCategoriesReq_EncodeDecode(t *testing.T) {
	var typ CreatePetCategoriesReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreatePetCategoriesReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreatePetFriendsReq_EncodeDecode(t *testing.T) {
	var typ CreatePetFriendsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreatePetFriendsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreatePetOwnerReq_EncodeDecode(t *testing.T) {
	var typ CreatePetOwnerReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreatePetOwnerReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCreatePetReq_EncodeDecode(t *testing.T) {
	var typ CreatePetReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CreatePetReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListPetCategoriesOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ListPetCategoriesOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPetCategoriesOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListPetFriendsOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ListPetFriendsOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPetFriendsOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestListPetOKApplicationJSON_EncodeDecode(t *testing.T) {
	var typ ListPetOKApplicationJSON
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 ListPetOKApplicationJSON
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCategoriesCreate_EncodeDecode(t *testing.T) {
	var typ PetCategoriesCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCategoriesCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCategoriesList_EncodeDecode(t *testing.T) {
	var typ PetCategoriesList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCategoriesList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCreate_EncodeDecode(t *testing.T) {
	var typ PetCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCreateCategories_EncodeDecode(t *testing.T) {
	var typ PetCreateCategories
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCreateCategories
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetCreateOwner_EncodeDecode(t *testing.T) {
	var typ PetCreateOwner
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetCreateOwner
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetFriendsCreate_EncodeDecode(t *testing.T) {
	var typ PetFriendsCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetFriendsCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetFriendsList_EncodeDecode(t *testing.T) {
	var typ PetFriendsList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetFriendsList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetList_EncodeDecode(t *testing.T) {
	var typ PetList
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetList
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetOwnerCreate_EncodeDecode(t *testing.T) {
	var typ PetOwnerCreate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetOwnerCreate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetOwnerRead_EncodeDecode(t *testing.T) {
	var typ PetOwnerRead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetOwnerRead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetRead_EncodeDecode(t *testing.T) {
	var typ PetRead
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetRead
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPetUpdate_EncodeDecode(t *testing.T) {
	var typ PetUpdate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PetUpdate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestR400_EncodeDecode(t *testing.T) {
	var typ R400
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 R400
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestR404_EncodeDecode(t *testing.T) {
	var typ R404
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 R404
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestR409_EncodeDecode(t *testing.T) {
	var typ R409
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 R409
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestR500_EncodeDecode(t *testing.T) {
	var typ R500
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 R500
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestUpdatePetReq_EncodeDecode(t *testing.T) {
	var typ UpdatePetReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 UpdatePetReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
